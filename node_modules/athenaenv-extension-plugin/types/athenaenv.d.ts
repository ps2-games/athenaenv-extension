// AthenaENV Global Types for PlayStation 2
// This file provides IntelliSense for AthenaENV JavaScript runtime
// DOM types are intentionally excluded as this runs on PS2, not browsers

declare global {
  /**
 * std module - Standard library wrappers and utilities
 * Provides wrappers to libc stdlib.h and stdio.h plus additional utilities
 */
  namespace std {
    /**
     * Evaluate a string as a script (global eval)
     * @param str - The string to evaluate as a script
     * @param options - Optional evaluation options
     * @param options.backtrace_barrier - If true, error backtraces do not list stack frames below evalScript (default: false)
     * @returns The result of the evaluated script
     */
    function evalScript(str: string, options?: { backtrace_barrier?: boolean }): any;

    /**
     * Evaluate a file as a script (global eval)
     * @param filename - Path to the file to evaluate
     * @returns The result of the evaluated script
     */
    function loadScript(filename: string): any;

    /**
     * Check if a file exists
     * @param filename - Path to the file to check
     * @returns true if the file exists, false otherwise
     */
    function exists(filename: string): boolean;

    /**
     * Load a file as a UTF-8 string
     * @param filename - Path to the file to load
     * @returns The file contents as a string, or null if I/O error occurs
     */
    function loadFile(filename: string): string | null;

    /**
     * Open a file (wrapper to libc fopen)
     * @param filename - Path to the file
     * @param flags - File mode (e.g., "w", "r", "wb", "rb")
     * @param errorObj - Optional object to receive error code
     * @returns FILE object or null if I/O error occurs
     */
    function open(filename: string, flags: string, errorObj?: { errno?: number }): FILE | null;

    /**
     * Open a file from a file handle (wrapper to libc fdopen)
     * @param fd - File descriptor
     * @param flags - File mode
     * @param errorObj - Optional object to receive error code
     * @returns FILE object or null if I/O error occurs
     */
    function fdopen(fd: number, flags: string, errorObj?: { errno?: number }): FILE | null;

    /**
     * Open a temporary file
     * @param errorObj - Optional object to receive error code
     * @returns FILE object or null if I/O error occurs
     */
    function tmpfile(errorObj?: { errno?: number }): FILE | null;

    /**
     * Output string with UTF-8 encoding (equivalent to std.out.puts)
     * @param str - String to output
     */
    function puts(str: string): void;

    /**
     * Formatted output (equivalent to std.out.printf)
     * @param fmt - Format string
     * @param args - Values to format
     */
    function printf(fmt: string, ...args: any[]): void;

    /**
     * Formatted string output (equivalent to libc sprintf)
     * @param fmt - Format string
     * @param args - Values to format
     * @returns Formatted string
     */
    function sprintf(fmt: string, ...args: any[]): string;

    /** Standard input stream wrapper */
    const in: FILE;
    /** Standard output stream wrapper */
    const out: FILE;
    /** Standard error stream wrapper */
    const err: FILE;

    /** Seek from beginning of file */
    const SEEK_SET: number;
    /** Seek from current position */
    const SEEK_CUR: number;
    /** Seek from end of file */
    const SEEK_END: number;

    // Error codes
    /** Invalid argument */
    const EINVAL: number;
    /** I/O error */
    const EIO: number;
    /** Permission denied */
    const EACCES: number;
    /** File exists */
    const EEXIST: number;
    /** No space left on device */
    const ENOSPC: number;
    /** Function not implemented */
    const ENOSYS: number;
    /** Device or resource busy */
    const EBUSY: number;
    /** No such file or directory */
    const ENOENT: number;
    /** Operation not permitted */
    const EPERM: number;
    /** Broken pipe */
    const EPIPE: number;

    /**
     * Get error description string
     * @param errno - Error code
     * @returns String describing the error
     */
    function strerror(errno: number): string;

    /**
     * Manually invoke cycle removal algorithm
     * Useful for specific memory constraints or testing
     */
    function gc(): void;

    /**
     * Parse extended JSON with additional syntax features
     * Features: comments, unquoted properties, trailing commas, single quotes, etc.
     * @param str - JSON string to parse
     * @returns Parsed object
     */
    function parseExtJSON(str: string): any;

    /**
     * Reload JavaScript environment with specified script
     * @param str - Script to reload environment with
     */
    function reload(str: string): void;
  }

  /**
   * FILE object for file operations
   */
  class FILE {
    /**
     * Close the file
     * @returns 0 if OK, -errno if I/O error occurs
     */
    close(): number;

    /**
     * Output string with UTF-8 encoding
     * @param str - String to output
     */
    puts(str: string): void;

    /**
     * Formatted printf output
     * @param fmt - Format string (supports standard C printf formats)
     * @param args - Values to format
     */
    printf(fmt: string, ...args: any[]): void;

    /**
     * Flush buffered file
     */
    flush(): void;

    /**
     * Seek to file position
     * @param offset - Position offset (number or bigint)
     * @param whence - Seek mode (std.SEEK_*)
     * @returns 0 if OK, -errno if I/O error occurs
     */
    seek(offset: number | bigint, whence: number): number;

    /**
     * Get current file position
     * @returns Current position as number
     */
    tell(): number;

    /**
     * Get current file position as bigint
     * @returns Current position as bigint
     */
    tello(): bigint;

    /**
     * Check if end of file reached
     * @returns true if EOF
     */
    eof(): boolean;

    /**
     * Get associated OS file handle
     * @returns File descriptor
     */
    fileno(): number;

    /**
     * Check if error occurred
     * @returns true if error
     */
    error(): boolean;

    /**
     * Clear error indication
     */
    clearerr(): void;

    /**
     * Read bytes from file into ArrayBuffer
     * @param buffer - ArrayBuffer to read into
     * @param position - Byte position in buffer
     * @param length - Number of bytes to read
     * @returns Number of bytes read
     */
    read(buffer: ArrayBuffer, position: number, length: number): number;

    /**
     * Write bytes from ArrayBuffer to file
     * @param buffer - ArrayBuffer to write from
     * @param position - Byte position in buffer
     * @param length - Number of bytes to write
     * @returns Number of bytes written
     */
    write(buffer: ArrayBuffer, position: number, length: number): number;

    /**
     * Read next line from file (UTF-8, excludes trailing line feed)
     * @returns Line string or null if EOF
     */
    getline(): string | null;

    /**
     * Read file as UTF-8 string
     * @param max_size - Maximum bytes to read (if undefined, reads to EOF)
     * @returns File contents as string
     */
    readAsString(max_size?: number): string;

    /**
     * Read next byte from file
     * @returns Byte value (0-255) or -1 if EOF
     */
    getByte(): number;

    /**
     * Write single byte to file
     * @param c - Byte value to write (0-255)
     */
    putByte(c: number): void;
  }

  /**
 * os module - Operating System specific functions
 * Provides low-level file access, signals, timers and asynchronous I/O.
 * Functions usually return 0 if OK or an OS-specific negative error code.
 */
  namespace os {
    /**
     * Open a file and return a file descriptor
     * @param filename - Path to the file
     * @param flags - POSIX open flags (os.O_* constants)
     * @param mode - File creation mode in octal (default: 0o666)
     * @returns File descriptor (≥ 0) or < 0 on error
     *
     * @example
     * const fd = os.open("file.txt", os.O_RDONLY);
     */
    function open(filename: string, flags: number, mode?: number): number;

    /** Open for reading only */
    const O_RDONLY: number;
    /** Open for writing only */
    const O_WRONLY: number;
    /** Open for reading and writing */
    const O_RDWR: number;
    /** Append on each write */
    const O_APPEND: number;
    /** Create file if it does not exist */
    const O_CREAT: number;
    /** Error if O_CREAT and the file exists */
    const O_EXCL: number;
    /** Truncate file to zero length */
    const O_TRUNC: number;

    /**
     * Close a file descriptor
     * @param fd - File descriptor to close
     * @returns 0 if OK, negative error code otherwise
     */
    function close(fd: number): number;

    /**
     * Seek to position in file
     * @param fd - File descriptor
     * @param offset - Position offset (number or bigint)
     * @param whence - Seek mode (use std.SEEK_* constants)
     * @returns New position (number or bigint matching offset type) or negative error code
     */
    function seek(fd: number, offset: number | bigint, whence: number): number | bigint;

    /**
     * Read bytes from file descriptor into ArrayBuffer
     * @param fd - File descriptor
     * @param buffer - ArrayBuffer to read into
     * @param offset - Byte offset in buffer
     * @param length - Number of bytes to read
     * @returns Number of bytes read (≥ 0) or negative error code
     */
    function read(fd: number, buffer: ArrayBuffer, offset: number, length: number): number;

    /**
     * Write bytes from ArrayBuffer to file descriptor
     * @param fd - File descriptor
     * @param buffer - ArrayBuffer to write from
     * @param offset - Byte offset in buffer
     * @param length - Number of bytes to write
     * @returns Number of bytes written (≥ 0) or negative error code
     */
    function write(fd: number, buffer: ArrayBuffer, offset: number, length: number): number;

    /**
     * Remove a file
     * @param filename - Path to the file
     * @returns 0 if OK, -errno on error
     */
    function remove(filename: string): number;

    /**
     * Rename a file
     * @param oldname - Current filename
     * @param newname - New filename
     * @returns 0 if OK, -errno on error
     */
    function rename(oldname: string, newname: string): number;

    /**
     * Get canonicalized absolute pathname
     * @param path - Path to resolve
     * @returns Tuple [absolutePath, errorCode] where errorCode is 0 on success
     */
    function realpath(path: string): [string, number];

    /**
     * Get current working directory
     * @returns Tuple [cwd, errorCode] where errorCode is 0 on success
     */
    function getcwd(): [string, number];

    /**
     * Change current directory
     * @param path - New working directory
     * @returns 0 if OK, -errno on error
     */
    function chdir(path: string): number;

    /**
     * Create a directory
     * @param path - Directory path
     * @param mode - Creation mode in octal (default: 0o777)
     * @returns 0 if OK, -errno on error
     */
    function mkdir(path: string, mode?: number): number;

    /**
     * File status information returned by stat/lstat
     */
    interface Stat {
      /** Device ID */
      dev: number;
      /** Inode number */
      ino: number;
      /** Mode (file type and permissions) */
      mode: number;
      /** Number of hard links */
      nlink: number;
      /** User ID */
      uid: number;
      /** Group ID */
      gid: number;
      /** Device ID (if special file) */
      rdev: number;
      /** Total size in bytes */
      size: number;
      /** Number of blocks allocated */
      blocks: number;
      /** Last access time (ms since 1970) */
      atime: number;
      /** Last modification time (ms since 1970) */
      mtime: number;
      /** Last status change time (ms since 1970) */
      ctime: number;
    }

    /**
     * Get file status
     * @param path - Path to the file
     * @returns Tuple [stat, errorCode] where stat is null on error
     */
    function stat(path: string): [Stat | null, number];

    /**
     * Get file status (does not follow symbolic links)
     * @param path - Path to the file
     * @returns Tuple [stat, errorCode] where stat is null on error
     */
    function lstat(path: string): [Stat | null, number];

    /** Bit mask for file type */
    const S_IFMT: number;
    /** FIFO */
    const S_IFIFO: number;
    /** Character device */
    const S_IFCHR: number;
    /** Directory */
    const S_IFDIR: number;
    /** Block device */
    const S_IFBLK: number;
    /** Regular file */
    const S_IFREG: number;
    /** Socket */
    const S_IFSOCK: number;
    /** Symbolic link */
    const S_IFLNK: number;
    /** Set-group-ID bit */
    const S_ISGID: number;
    /** Set-user-ID bit */
    const S_ISUID: number;

    /**
     * Change file access and modification times
     * @param path - Path to the file
     * @param atime - Access time in milliseconds since 1970
     * @param mtime - Modification time in milliseconds since 1970
     * @returns 0 if OK, -errno on error
     */
    function utimes(path: string, atime: number, mtime: number): number;

    /**
     * Read directory contents
     * @param path - Directory path
     * @returns Tuple [filenames, errorCode] where filenames is null on error
     */
    function readdir(path: string): [string[] | null, number];

    /**
     * Add read handler for file descriptor
     * @param fd - File descriptor
     * @param func - Handler function called when data is pending, or null to remove
     */
    function setReadHandler(fd: number, func: (() => void) | null): void;

    /**
     * Add write handler for file descriptor
     * @param fd - File descriptor
     * @param func - Handler function called when data can be written, or null to remove
     */
    function setWriteHandler(fd: number, func: (() => void) | null): void;

    /**
     * Sleep for specified milliseconds
     * @param delay_ms - Sleep duration in milliseconds
     */
    function sleep(delay_ms: number): void;

    /**
     * Set a one-time timer
     * @param func - Function to call after delay
     * @param delay - Delay in milliseconds
     * @returns Timer handle
     */
    function setTimeout(func: () => void, delay: number): number;

    /**
     * Set a repeating timer
     * @param func - Function to call at intervals
     * @param interval - Interval in milliseconds
     * @returns Timer handle
     */
    function setInterval(func: () => void, interval: number): number;

    /**
     * Execute function immediately after current execution
     * @param func - Function to execute
     * @returns Immediate handle
     */
    function setImmediate(func: () => void): number;

    /**
     * Cancel a timeout timer
     * @param handle - Timer handle returned by setTimeout
     */
    function clearTimeout(handle: number): void;

    /**
     * Cancel an interval timer
     * @param handle - Timer handle returned by setInterval
     */
    function clearInterval(handle: number): void;

    /**
     * Cancel an immediate execution
     * @param handle - Handle returned by setImmediate
     */
    function clearImmediate(handle: number): void;

    /** Platform identifier string ("ps2") */
    const platform: "ps2";
  }

  /**
   * Vector4 module - 4-component vector math
   * Provides 3D/4D vector operations with operator overloads
   * 4-component vector class
   */
  class Vector4 {
    /**
         * Create a new 4D vector
         * @param x - X component (default: 0)
         * @param y - Y component (default: 0)
         * @param z - Z component (default: 0)
         * @param w - W component (default: 0)
         *
         * @example
         * const vec = new Vector4(0.0, 0.0, 0.0, 1.0);
         */
    constructor(x?: number, y?: number, z?: number, w?: number);

    /** X component */
    x: number;
    /** Y component */
    y: number;
    /** Z component */
    z: number;
    /** W component */
    w: number;

    /**
     * Get vector length (Euclidean norm)
     * @returns Length of the vector
     */
    norm(): number;

    /**
     * Calculate dot product with another vector
     * @param vec2 - Other vector
     * @returns Dot product value
     */
    dot(vec2: Vector4): number;

    /**
     * Calculate cross product with another vector (3D cross product, w is ignored)
     * @param vec2 - Other vector
     * @returns New vector with cross product result
     */
    cross(vec2: Vector4): Vector4;

    /**
     * Calculate distance to another vector
     * @param vec2 - Other vector
     * @returns Euclidean distance
     */
    distance(vec2: Vector4): number;

    /**
     * Calculate squared distance to another vector (faster than distance())
     * @param vec2 - Other vector
     * @returns Squared Euclidean distance
     */
    distance2(vec2: Vector4): number;

    /**
     * Vector addition
     * @param other - Vector to add
     * @returns New vector with component-wise sum
     */
    add(other: Vector4): Vector4;

    /**
     * Vector subtraction
     * @param other - Vector to subtract
     * @returns New vector with component-wise difference
     */
    sub(other: Vector4): Vector4;

    /**
     * Vector scalar multiplication
     * @param scalar - Scalar value
     * @returns New vector with components multiplied by scalar
     */
    mul(scalar: number): Vector4;

    /**
     * Vector scalar division
     * @param scalar - Scalar value
     * @returns New vector with components divided by scalar
     */
    div(scalar: number): Vector4;

    /**
     * Vector equality comparison
     * @param other - Vector to compare
     * @returns true if all components are equal
     */
    eq(other: Vector4): boolean;
  }

  /**
   * Matrix4 module - 4x4 matrix math for 3D transformations
   * 
   * Supports construction from 16 elements or identity, with full operator overloads
   * 
   * 4x4 matrix class stored in column-major order
   */
  class Matrix4 {
    /**
         * Create a 4×4 matrix.
         * @param m1-m16  Matrix elements in column-major order (indices 0-15).
         *                If no arguments are supplied, an identity matrix is created.
         *
         * @example
         * // Identity matrix
         * const m = new Matrix4();
         *
         * // Custom matrix
         * const m = new Matrix4(
         *   1, 0, 0, 0,
         *   0, 1, 0, 0,
         *   0, 0, 1, 0,
         *   0, 0, 0, 1
         * );
         */
    constructor(
      m1?: number, m2?: number, m3?: number, m4?: number,
      m5?: number, m6?: number, m7?: number, m8?: number,
      m9?: number, m10?: number, m11?: number, m12?: number,
      m13?: number, m14?: number, m15?: number, m16?: number
    );

    /** Always 16 (read-only) */
    readonly length: 16;

    /**
     * Direct element access by index (column-major, 0-15)
     * mat[0]  = m00  mat[4]  = m01  mat[8]  = m02  mat[12] = m03
     * mat[1]  = m10  mat[5]  = m11  mat[9]  = m12  mat[13] = m13
     * mat[2]  = m20  mat[6]  = m21  mat[10] = m22  mat[14] = m23
     * mat[3]  = m30  mat[7]  = m31  mat[11] = m32  mat[15] = m33
     */
    [n: number]: number;

    /**
     * Convert matrix to a plain JavaScript array (column-major order)
     * @returns Array of 16 numbers
     */
    toArray(): number[];

    /**
     * Set matrix elements from the first 16 values of an array
     * @param arr Source array (must have length ≥ 16)
     * @returns This matrix for chaining
     */
    fromArray(arr: number[]): Matrix4;

    /**
     * Create an independent copy of this matrix
     * @returns New Matrix4 with identical elements
     */
    clone(): Matrix4;

    /**
     * Copy all elements into another matrix instance
     * @param mat Target matrix to overwrite
     * @returns The supplied target matrix
     */
    copy(mat: Matrix4): Matrix4;

    /**
     * Transpose matrix in place
     * @returns This matrix for chaining
     */
    transpose(): Matrix4;

    /**
     * Replace this matrix with its inverse.
     * @returns This matrix for chaining.
     * @throws {Error} If the matrix is singular (not invertible)
     */
    invert(): Matrix4;

    /**
     * Replace this matrix with the 4×4 identity matrix
     * @returns This matrix for chaining
     */
    identity(): Matrix4;

    /**
     * Matrix-matrix multiplication (pre-multiply: this = mat × this)
     * @param mat Right-hand side matrix
     * @returns New Matrix4 with the product
     */
    mul(mat: Matrix4): Matrix4;

    /**
     * Component-wise equality check with another matrix
     * @param mat Matrix to compare
     * @returns true if all elements are identical
     */
    eq(mat: Matrix4): boolean;
  }

  /**
 * Color module - RGBA color manipulation utilities
 * 
 * Provides factory functions and getters/setters for 32-bit packed colors
 */
  namespace Color {
    /**
         * Create a new packed RGBA color
         * @param r - Red intensity (0-255)
         * @param g - Green intensity (0-255)
         * @param b - Blue intensity (0-255)
         * @param a - Alpha intensity (0-255, default: 255)
         * @returns 32-bit packed color value
         *
         * @example
         * const red = Color.new(255, 0, 0);
         * const translucent = Color.new(0, 128, 255, 128);
         */
    function new (r: number, g: number, b: number, a ?: number): number;

    /**
     * Extract red channel from packed color
     * @param col - Packed color value
     * @returns Red intensity (0-255)
     */
    function getR(col: number): number;

    /**
     * Extract green channel from packed color
     * @param col - Packed color value
     * @returns Green intensity (0-255)
     */
    function getG(col: number): number;

    /**
     * Extract blue channel from packed color
     * @param col - Packed color value
     * @returns Blue intensity (0-255)
     */
    function getB(col: number): number;

    /**
     * Extract alpha channel from packed color
     * @param col - Packed color value
     * @returns Alpha intensity (0-255)
     */
    function getA(col: number): number;

    /**
     * Set red channel in packed color
     * @param col - Packed color value to modify
     * @param r - New red intensity (0-255)
     * @returns New packed color with updated red channel
     */
    function setR(col: number, r: number): number;

    /**
     * Set green channel in packed color
     * @param col - Packed color value to modify
     * @param g - New green intensity (0-255)
     * @returns New packed color with updated green channel
     */
    function setG(col: number, g: number): number;

    /**
     * Set blue channel in packed color
     * @param col - Packed color value to modify
     * @param b - New blue intensity (0-255)
     * @returns New packed color with updated blue channel
     */
    function setB(col: number, b: number): number;

    /**
     * Set alpha channel in packed color
     * @param col - Packed color value to modify
     * @param a - New alpha intensity (0-255)
     * @returns New packed color with updated alpha channel
     */
    function setA(col: number, a: number): number;
  }

  /**
 * Filter modes used when the source rectangle does not match 1:1 texels.
 */
  enum ImageFilter {
    /** Nearest-neighbour (blocky, fast) */
    NEAREST = 0,
    /** Bilinear (smooth) */
    LINEAR = 1,
  }

  /**
   * Queue that loads images in a background thread.
   * Create **one** instance and re-use it; do NOT build many per frame.
   */
  class ImageList {
    constructor();

    /**
     * Start the worker thread and consume every path previously added via
     * `new Image(path, this)`. Call once per frame until `image.ready()`
     * returns true for every queued asset.
     */
    process(): void;
  }

  /**
  * In-memory texture that can be blitted to the frame-buffer or used as
  * a render target. Pixel data may live in main RAM (swappable) or be
  * locked into VRAM.
  */
  class Image {
    /**
     * Build an image container.
     * @param path         File to load (PNG, JPG, BMP, …).  If omitted the
     *                     object is created empty and must be filled later
     *                     (e.g.  by copying VRAM blocks).
     * @param asyncList    Optional `ImageList` that will own the background
     *                     load job. When supplied the constructor returns
     *                     immediately and `ready()` must be polled.
     *
     * @example
     * // Synchronous load
     * const logo = new Image("assets/logo.png");
     *
     * // Asynchronous load
     * const queue = new ImageList();
     * const hero  = new Image("chars/hero.png", queue);
     * queue.process();   // start thread
     * // … later …
     * if (hero.ready()) hero.draw(0, 0);
     */
    constructor(path?: string, asyncList?: ImageList);

    /* -------------------------------------------------------------- */
    /* Drawing region (texels that will be sampled)                   */
    /* -------------------------------------------------------------- */

    /** First pixel column to sample (default: 0) */
    startX: number;
    /** First pixel row to sample (default: 0) */
    startY: number;
    /** Last pixel column + 1 (default: image width) */
    endX: number;
    /** Last pixel row + 1 (default: image height) */
    endY: number;

    /* -------------------------------------------------------------- */
    /* On-screen transform                                            */
    /* -------------------------------------------------------------- */

    /** Horizontal size on screen in pixels (default: pixel width) */
    width: number;
    /** Vertical size on screen in pixels (default: pixel height) */
    height: number;
    /** Rotation angle in degrees, clockwise around centre (default: 0) */
    angle: number;
    /** Tint colour multiplied with every texel (default: white, 128 α) */
    color: number; // packed RGBA via Color.new

    /** Filter to use when scaling (default: NEAREST) */
    filter: ImageFilter;

    /* -------------------------------------------------------------- */
    /* Memory layout introspection                                    */
    /* -------------------------------------------------------------- */

    /** Real width of texture in VRAM (power-of-two) */
    readonly texWidth: number;
    /** Real height of texture in VRAM (power-of-two) */
    readonly texHeight: number;
    /** Bytes consumed by the texture (including padding) */
    readonly size: number;
    /** Bits per pixel (4, 8, 16, 24, 32) */
    readonly bpp: number;
    /** Raw pixel bytes (ArrayBuffer) – valid while texture is bound */
    readonly pixels: ArrayBuffer;
    /** Palette entries for indexed formats (ArrayBuffer) */
    readonly palette: ArrayBuffer | null;
    /** When true the image can be used as a colour attachment */
    renderable: boolean;

    /* -------------------------------------------------------------- */
    /* VRAM life-time control                                         */
    /* -------------------------------------------------------------- */

    /**
     * Pin the texture in VRAM so it cannot be evicted.  Call for assets
     * that are referenced every frame or for render targets.
     */
    lock(): void;

    /** Allow the texture to be swapped out when memory is low. */
    unlock(): void;

    /** @returns true if the texture is currently locked. */
    locked(): boolean;

    /* -------------------------------------------------------------- */
    /* CPU-side manipulation                                          */
    /* -------------------------------------------------------------- */

    /**
     * Down-convert 24-bit RGB → 16-bit RGB (565) in place.
     * Reduces memory footprint by ~33 % at the cost of banding.
     * Only valid for 24-bpp sources.
     */
    optimize(): void;

    /* -------------------------------------------------------------- */
    /* Rendering                                                      */
    /* -------------------------------------------------------------- */

    /**
     * Blit the configured region to the frame-buffer.
     * @param x Left corner in screen space
     * @param y Top  corner in screen space
     *
     * @example
     * // every frame
     * bg.draw(0, 0);
     */
    draw(x: number, y: number): void;

    /* -------------------------------------------------------------- */
    /* Asynchronous loading                                           */
    /* -------------------------------------------------------------- */

    /**
     * @returns true when an async load (via ImageList) has finished
     *          and the texture is ready to draw.
     */
    ready(): boolean;

    /* -------------------------------------------------------------- */
    /* Explicit memory management                                     */
    /* -------------------------------------------------------------- */

    /**
     * Immediately release GPU resources and pixel data.
     * The object becomes invalid; drawing will throw.
     * (Garbage collection will do this eventually – this is just faster.)
     */
    free(): void;
  }

  /**
 * Image module – 2D asset loading, VRAM management and on-screen blitting
 * Supports synchronous/asynchronous loading, partial blitting, palette and
 * true-color formats, plus optional rotation and tinting.
 */
  namespace Image {
    /**
     * Low-level VRAM-to-VRAM copy.  Both buffers must be valid Image
     * instances whose pixels are currently resident.
     *
     * @param srcBuffer Source Image
     * @param srcX      Source rectangle left
     * @param srcY      Source rectangle top
     * @param destBuffer Destination Image
     * @param destX     Destination rectangle left
     * @param destY     Destination rectangle top
     * @param width     Rectangle width (optional – uses full src region)
     * @param height    Rectangle height (optional – uses full src region)
     */
    function copyVRAMBlock(
      srcBuffer: Image,
      srcX: number,
      srcY: number,
      destBuffer: Image,
      destX: number,
      destY: number,
      width?: number,
      height?: number
    ): void;
  }

  /**
     * Draw module - Primitive 2D drawing functions
     * Provides pixel, rectangle, line, circle, triangle, and quad drawing functions
     */
  namespace Draw {
    /**
     * Draws a pixel on the specified color and position on the screen
     * @param x - X coordinate of the pixel
     * @param y - Y coordinate of the pixel
     * @param color - Packed RGBA color value (from Color.new)
     */
    function point(x: number, y: number, color: number): void;

    /**
     * Draws a rectangle on the specified color, position and size on the screen
     * @param x - X coordinate of the rectangle's top-left corner
     * @param y - Y coordinate of the rectangle's top-left corner
     * @param width - Width of the rectangle in pixels
     * @param height - Height of the rectangle in pixels
     * @param color - Packed RGBA color value (from Color.new)
     */
    function rect(x: number, y: number, width: number, height: number, color: number): void;

    /**
     * Draws a line on the specified colors and position on the screen
     * @param x - X coordinate of the line's starting point
     * @param y - Y coordinate of the line's starting point
     * @param x2 - X coordinate of the line's ending point
     * @param y2 - Y coordinate of the line's ending point
     * @param color - Packed RGBA color value (from Color.new)
     */
    function line(x: number, y: number, x2: number, y2: number, color: number): void;

    /**
     * Draws a circle on the specified color, position, radius and fill on the screen
     * @param x - X coordinate of the circle's center
     * @param y - Y coordinate of the circle's center
     * @param radius - Radius of the circle in pixels
     * @param color - Packed RGBA color value (from Color.new)
     * @param filled - Whether to fill the circle (default: false)
     */
    function circle(x: number, y: number, radius: number, color: number, filled?: boolean): void;

    /**
     * Draws a triangle on the specified points positions and colors on the screen
     * @param x - X coordinate of the first vertex
     * @param y - Y coordinate of the first vertex
     * @param x2 - X coordinate of the second vertex
     * @param y2 - Y coordinate of the second vertex
     * @param x3 - X coordinate of the third vertex
     * @param y3 - Y coordinate of the third vertex
     * @param color - Packed RGBA color value for the first vertex (from Color.new)
     * @param color2 - Optional packed RGBA color value for the second vertex (default: same as color)
     * @param color3 - Optional packed RGBA color value for the third vertex (default: same as color)
     */
    function triangle(
      x: number, y: number,
      x2: number, y2: number,
      x3: number, y3: number,
      color: number,
      color2?: number,
      color3?: number
    ): void;

    /**
     * Draws a quad on the specified points positions and colors on the screen
     * @param x - X coordinate of the first vertex
     * @param y - Y coordinate of the first vertex
     * @param x2 - X coordinate of the second vertex
     * @param y2 - Y coordinate of the second vertex
     * @param x3 - X coordinate of the third vertex
     * @param y3 - Y coordinate of the third vertex
     * @param x4 - X coordinate of the fourth vertex
     * @param y4 - Y coordinate of the fourth vertex
     * @param color - Packed RGBA color value for the first vertex (from Color.new)
     * @param color2 - Optional packed RGBA color value for the second vertex (default: same as color)
     * @param color3 - Optional packed RGBA color value for the third vertex (default: same as color)
     * @param color4 - Optional packed RGBA color value for the fourth vertex (default: same as color)
     */
    function quad(
      x: number, y: number,
      x2: number, y2: number,
      x3: number, y3: number,
      x4: number, y4: number,
      color: number,
      color2?: number,
      color3?: number,
      color4?: number
    ): void;
  }

  /**
   * TileMap module - Tile-based rendering system
   * Provides descriptor/buffer-based API for efficient tile and sprite rendering
   */
  namespace TileMap {
    /**
     * Material configuration for tilemap descriptors
     */
    interface TileMapMaterial {
      /** Index into the textures array */
      texture_index: number;
      /** Blending mode */
      blend_mode: number;
      /** End offset for this material */
      end_offset: number;
    }

    /**
     * TileMap descriptor configuration
     */
    interface TileMapDescriptorConfig {
      /** Array of texture paths or Image objects */
      textures: Array<string | Image>;
      /** Array of material configurations */
      materials: TileMapMaterial[];
    }

    /**
     * Immutable tilemap descriptor
     */
    class Descriptor {
      /**
       * Create a tilemap descriptor
       * @param config - Descriptor configuration
       */
      constructor(config: TileMapDescriptorConfig);
    }

    /**
     * Layout information for sprite buffer packing
     */
    const layout: {
      /** Byte stride of each sprite in the buffer */
      stride: number;
      /** Byte offsets for each sprite field */
      offsets: {
        x: number;
        y: number;
        w: number;
        h: number;
        u1: number;
        v1: number;
        u2: number;
        v2: number;
        r: number;
        g: number;
        b: number;
        a: number;
        zindex: number;
      };
    };

    /**
     * TileMap instance options
     */
    interface TileMapInstanceOptions {
      /** Tilemap descriptor */
      descriptor: Descriptor;
      /** Sprite buffer (ArrayBuffer) */
      spriteBuffer: ArrayBuffer;
    }

    /**
     * TileMap instance bound to a sprite buffer
     */
    class Instance {
      /**
       * Create a tilemap instance
       * @param options - Instance configuration
       */
      constructor(options: TileMapInstanceOptions);

      /**
       * Draw the tilemap at the specified offset
       * @param x - X offset for rendering
       * @param y - Y offset for rendering
       * @param zindex - Optional z-index override
       */
      render(x: number, y: number, zindex?: number): void;

      /**
       * Swap the current buffer pointer
       * @param buffer - New sprite buffer
       */
      replaceSpriteBuffer(buffer: ArrayBuffer): void;

      /**
       * Get the attached sprite buffer for direct mutation
       * @returns The attached ArrayBuffer
       */
      getSpriteBuffer(): ArrayBuffer;

      /**
       * Copy a range of sprites from another buffer
       * @param dstOffset - Destination offset in sprites (not bytes)
       * @param srcBuffer - Source buffer containing sprite data
       * @param spriteCount - Number of sprites to copy (default: all remaining in srcBuffer)
       */
      updateSprites(dstOffset: number, srcBuffer: ArrayBuffer, spriteCount?: number): void;
    }

    /**
     * Sprite buffer utilities
     */
    namespace SpriteBuffer {
      /**
       * Allocate a zeroed buffer sized for the specified number of sprites
       * @param count - Number of sprites
       * @returns Allocated ArrayBuffer
       */
      function create(count: number): ArrayBuffer;

      /**
       * Convert an array of JS objects into a packed buffer
       * @param array - Array of sprite objects with properties: x, y, w, h, u1, v1, u2, v2, r, g, b, a, zindex
       * @returns Packed ArrayBuffer
       */
      function fromObjects(array: Array<{
        x: number;
        y: number;
        w: number;
        h: number;
        u1: number;
        v1: number;
        u2: number;
        v2: number;
        r: number;
        g: number;
        b: number;
        a: number;
        zindex?: number;
      }>): ArrayBuffer;
    }

    /**
     * Low-level renderer initialization
     * Must be called once before any tilemap operations
     */
    function init(): void;

    /**
     * Begin a new rendering frame
     * Must be called at the start of each frame
     */
    function begin(): void;

    /**
     * Set the shared camera offset for all tilemaps
     * @param x - X camera offset
     * @param y - Y camera offset
     */
    function setCamera(x: number, y: number): void;
  }

  /**
   * RenderBatch options
   */
  interface BatchOptions {
    /** Enables internal state-aware sort (default: true) */
    autoSort?: boolean;
  }

  /**
   * RenderBatch class - Batched rendering system
   */
  class Batch {
    /**
     * Create a new render batch
     * @param options - Batch configuration options
     */
    constructor(options?: BatchOptions);

    /**
     * Adds a RenderObject to the batch
     * @param renderObject - The RenderObject to add
     * @returns Current count of objects in the batch
     */
    add(renderObject: RenderObject): number;

    /**
     * Removes all objects from the batch
     */
    clear(): void;

    /**
     * Renders all objects in the batch using optimal state transitions
     * @returns Number of draw calls performed
     */
    render(): number;

    /**
     * Number of objects currently in the batch (read-only)
     */
    readonly size: number;
  }

  /**
   * SceneNode class - Scene graph node for hierarchical transformations
   */
  class SceneNode {
    /**
     * Create a new scene node
     */
    constructor();

    /**
     * Parent a child SceneNode to this node
     * @param node - Child node to add
     */
    addChild(node: SceneNode): void;

    /**
     * Unparent a specific child from this node
     * @param node - Child node to remove
     */
    removeChild(node: SceneNode): void;

    /**
     * Attach a RenderObject to this node
     * @param renderObject - The RenderObject to attach
     */
    attach(renderObject: RenderObject): void;

    /**
     * Detach the specific object or all when omitted
     * @param renderObject - Optional specific RenderObject to detach
     */
    detach(renderObject?: RenderObject): void;

    /**
     * Recomputes world transforms (rotate → scale → translate) for this subtree
     */
    update(): void;

    /** Position in 3D space */
    position: { x: number; y: number; z: number };

    /** Rotation in 3D space (in degrees or radians based on engine) */
    rotation: { x: number; y: number; z: number };

    /** Scale in 3D space */
    scale: { x: number; y: number; z: number };
  }

  /**
 * AsyncLoader options
 */
  interface AsyncLoaderOptions {
    /** How many items to process per process() call when budget is omitted (default: 1) */
    jobsPerStep?: number;
  }

  /**
   * AsyncLoader class - Cooperative streaming helper for model loading
   * Executed on the main thread in small steps
   */
  class AsyncLoader {
    /**
     * Create a new async loader
     * @param options - Loader configuration options
     */
    constructor(options?: AsyncLoaderOptions);

    /**
     * Queues a model load
     * @param path - Model file path (e.g., "BoxTextured.gltf")
     * @param callback - Function invoked when the item is ready
     * @param texture - Optional Image to bind during load (may be null/omitted)
     */
    enqueue(path: string, callback: (path: string, renderData: RenderData) => void, texture?: Image | null): void;

    /**
     * Processes items from the queue
     * @param budget - Maximum number of items to process (uses jobsPerStep if omitted)
     * @returns Number of items processed
     */
    process(budget?: number): number;

    /**
     * Clears pending items and releases their callbacks
     */
    clear(): void;

    /**
     * Clears and destroys the loader
     */
    destroy(): void;

    /**
     * Returns number of items still pending
     * @returns Number of pending items
     */
    size(): number;

    /**
     * Returns current jobs-per-step setting
     * @returns Current jobs-per-step value
     */
    getJobsPerStep(): number;

    /**
     * Sets jobs-per-step value
     * @param n - New jobs-per-step value (clamped to at least 1)
     * @returns The applied value
     */
    setJobsPerStep(n: number): number;
  }

  /**
   * Material descriptor interface
   */
  interface MaterialDescriptor {
    ambient: number;
    diffuse: number;
    specular: number;
    emission: number;
    transmittance: number;
    shininess: number;
    refraction: number;
    transmission_filter: number;
    dissolve: number;
    texture_id: number;
    bump_texture_id: number;
    ref_texture_id: number;
    decal_texture_id: number;
  }

  /**
   * Color object for materials
   */
  interface MaterialColor {
    r: number;
    g: number;
    b: number;
    a: number;
  }

  /**
   * Mesh bounds interface
   */
  interface MeshBounds {
    min: Vector4;
    max: Vector4;
  }

  /**
   * Bone data structure for skinned meshes
   */
  interface BoneData {
    /** Bone local position */
    position: Vector4;
    /** Bone local rotation */
    rotation: Vector4;
    /** Bone local scale */
    scale: Vector4;
    /** Bone inverse bind matrix */
    inverse_bind: Matrix4;
  }

  /**
   * Current bone state for skinned meshes
   */
  interface CurrentBoneData {
    /** Current bone local position */
    position: Vector4;
    /** Current bone local rotation */
    rotation: Vector4;
    /** Current bone local scale */
    scale: Vector4;
    /** Current bone RTS matrix */
    transform: Matrix4;
  }

  /**
   * Render module - 3D rendering system
   */
  namespace Render {
    /**
     * Initializes internal renderer state (GS/VU microprograms, materials cache)
     * Call once during boot
     */
    function init(): void;

    /**
     * Starts a render pass and resets batched state
     * Call once per frame before issuing draw calls
     */
    function begin(): void;

    /**
     * Configures the default projection matrix
     * @param fov - Field of view in degrees (default: 60)
     * @param nearClip - Near clipping plane distance (default: 1.0)
     * @param farClip - Far clipping plane distance (default: 2000.0)
     * @param width - Override width for aspect ratio (default: 0.0 = auto-derived)
     * @param height - Override height for aspect ratio (default: 0.0 = auto-derived)
     */
    function setView(fov?: number, nearClip?: number, farClip?: number, width?: number, height?: number): void;

    /**
     * Convenience helper that returns a color object for materials
     * @param r - Red component (0.0-1.0)
     * @param g - Green component (0.0-1.0)
     * @param b - Blue component (0.0-1.0)
     * @param alpha - Alpha component (0.0-1.0, default: 1.0)
     * @returns Material color object
     */
    function materialColor(r: number, g: number, b: number, alpha?: number): MaterialColor;

    /**
     * Builds a material descriptor used by RenderData/RenderObject
     * @param ambient - Ambient component
     * @param diffuse - Diffuse component
     * @param specular - Specular component
     * @param emission - Emission component
     * @param transmittance - Transmittance component
     * @param shininess - Shininess component
     * @param refraction - Refraction index
     * @param transmission_filter - Transmission filter
     * @param dissolve - Dissolve (transparency)
     * @param texture_id - Texture ID or -1 to disable
     * @param bump_texture_id - Bump texture ID or -1 to disable
     * @param ref_texture_id - Reflection texture ID or -1 to disable
     * @param decal_texture_id - Decal texture ID or -1 to disable
     * @returns Material descriptor
     */
    function material(
      ambient: number,
      diffuse: number,
      specular: number,
      emission: number,
      transmittance: number,
      shininess: number,
      refraction: number,
      transmission_filter: number,
      dissolve: number,
      texture_id: number,
      bump_texture_id: number,
      ref_texture_id: number,
      decal_texture_id: number
    ): MaterialDescriptor;

    /**
     * Tags the vertex/material arrays so the renderer knows which faces should use each material slice
     * @param index - Material index
     * @param end - End index for this material slice
     */
    function materialIndex(index: number, end: number): void;

    /**
     * Creates the structure expected by new RenderData(...)
     * @param positions - Typed array with 4-component positions (xyzw)
     * @param normals - Typed array with 4-component normals (n1n2n3w)
     * @param texcoords - Typed array with 4-component texture coordinates (stqw)
     * @param colors - Typed array with 4-component colors (rgba)
     * @param materials - Array of material descriptors
     * @param material_indices - Array of material indices
     * @returns Vertex list structure
     */
    function vertexList(
      positions: Float32Array,
      normals: Float32Array,
      texcoords: Float32Array,
      colors: Float32Array,
      materials: MaterialDescriptor[],
      material_indices: number[]
    ): any; // Return type is internal structure

    /** No lighting pipeline - Lights disabled, colors still working */
    const PL_NO_LIGHTS: number;

    /** Default pipeline for textured models - Lights and colors enabled */
    const PL_DEFAULT: number;

    /** Specular pipeline - Diffuse and specular lights and colors enabled */
    const PL_SPECULAR: number;

    /** No face culling */
    const CULL_FACE_NONE: number;

    /** Back face culling */
    const CULL_FACE_BACK: number;

    /** Front face culling */
    const CULL_FACE_FRONT: number;
  }

  /**
   * RenderData class - 3D model data container
   */
  class RenderData {
    /**
     * Create new render data
     * @param mesh - Mesh data (file path or vertex arrays)
     * @param texture - Optional texture image for models without MTL files
     */
    constructor(mesh: string | any, texture?: Image);

    /**
     * Gets the nth texture object from the model
     * @param id - Texture index
     * @returns Texture image or null
     */
    getTexture(id: number): Image | null;

    /**
     * Changes or sets the nth texture on models
     * @param id - Texture index
     * @param texture - New texture image
     */
    setTexture(id: number, texture: Image): void;

    /**
     * Free asset content immediately
     * Note: This is optional - you can also wait for garbage collection
     */
    free(): void;

    /** Float32Array with x, y, z, adc for each vertex */
    positions: Float32Array;

    /** Float32Array with n1, n2, n3, adc for each vertex */
    normals: Float32Array;

    /** Float32Array with s, t, q, w for each vertex */
    texcoords: Float32Array;

    /** Float32Array with r, g, b, a for each vertex */
    colors: Float32Array;

    /** Rendering pipeline */
    pipeline: number; // Render.PL_* constants

    /** Array of material descriptors */
    materials: MaterialDescriptor[];

    /** Array of material indices */
    material_indices: number[];

    /** Vertex quantity */
    size: number;

    /** Mesh bounding box */
    bounds: MeshBounds;

    /** Toggle accurate clipping */
    accurate_clipping: boolean;

    /** Face culling mode (default: Render.CULL_FACE_BACK) */
    face_culling: number; // Render.CULL_FACE_* constants

    /** Toggle texture mapping (can be used to disable texturing on a whole textured model) */
    texture_mapping: boolean;

    /** Shade model: Flat = 0, Gouraud = 1 */
    shade_model: number;

    // Skinned mesh properties
    /** Skeleton bones data (only for skinned meshes) */
    bones?: BoneData[];

    /** Vertex weights for skinning (only for skinned meshes) */
    bone_weights?: Float32Array;

    /** Bone indices for skinning (only for skinned meshes) */
    bone_indices?: Uint8Array;
  }

  /**
   * AnimCollection class - Animation collection container
   */
  class AnimCollection {
    /**
     * Create a new animation collection
     * @param path - Path to animation file (e.g., "walk_anims.gltf")
     */
    constructor(path: string);

    /**
     * Get animation by name or index
     * @param key - Animation name or index
     * @returns Animation data
     */
    [key: string | number]: any; // Index signature for animation access
  }

  /**
   * RenderObject class - 3D renderable object with transform
   */
  class RenderObject {
    /**
     * Create a new render object
     * @param renderData - RenderData containing mesh and material information
     */
    constructor(renderData: RenderData);

    /**
     * Draws the object on screen
     */
    render(): void;

    /**
     * Draws object bounding box
     */
    renderBounds(): void;

    /**
     * Free asset content immediately
     * Note: This is optional - you can also wait for garbage collection
     */
    free(): void;

    // Skinned mesh methods
    /**
     * Play animation on a skinned RenderObject
     * @param anim - Animation from AnimCollection
     * @param loop - Whether to loop the animation
     */
    playAnim(anim: any, loop: boolean): void;

    /**
     * Check if animation is being played
     * @param anim - Animation to check
     * @returns true if anim is being played
     */
    isPlayingAnim(anim: any): boolean;

    /** Object position {x, y, z} (default: {x:0, y:0, z:0}) */
    position: { x: number; y: number; z: number };

    /** Object rotation {x, y, z} (default: {x:0, y:0, z:0}) */
    rotation: { x: number; y: number; z: number };

    /** Object scale {x, y, z} (default: {x:1, y:1, z:1}) */
    scale: { x: number; y: number; z: number };

    /** Object RTS transform matrix */
    transform: Matrix4;

    // Skinned mesh properties
    /** Array of Matrix4 containing the current bone state (only for skinned meshes) */
    bone_matrices?: Matrix4[];

    /** Current bones data (only for skinned meshes) */
    bones?: CurrentBoneData[];
  }

  /**
 * Camera module - 3D camera control system
 */
  namespace Camera {
    /**
     * Set camera position
     * @param x - X coordinate
     * @param y - Y coordinate
     * @param z - Z coordinate
     */
    function position(x: number, y: number, z: number): void;

    /**
     * Set camera rotation (in degrees)
     * @param x - Rotation around X axis (pitch)
     * @param y - Rotation around Y axis (yaw)
     * @param z - Rotation around Z axis (roll)
     */
    function rotation(x: number, y: number, z: number): void;

    /**
     * Set camera target position (look-at point)
     * @param x - Target X coordinate
     * @param y - Target Y coordinate
     * @param z - Target Z coordinate
     */
    function target(x: number, y: number, z: number): void;

    /**
     * Orbit camera around target
     * @param yaw - Yaw angle in degrees
     * @param pitch - Pitch angle in degrees
     */
    function orbit(yaw: number, pitch: number): void;

    /**
     * Turn camera (rotate in place)
     * @param yaw - Yaw angle in degrees
     * @param pitch - Pitch angle in degrees
     */
    function turn(yaw: number, pitch: number): void;

    /**
     * Pan camera (move horizontally/vertically while maintaining orientation)
     * @param x - Horizontal pan amount
     * @param y - Vertical pan amount
     */
    function pan(x: number, y: number): void;

    /**
     * Move camera forward/backward along view direction
     * @param distance - Distance to move (positive = forward, negative = backward)
     */
    function dolly(distance: number): void;

    /**
     * Zoom camera (adjust field of view or move along view direction)
     * @param distance - Zoom distance/amount
     */
    function zoom(distance: number): void;

    /**
     * Update camera state (must be called every frame)
     */
    function update(): void;
  }

  /**
   * Lights module - 3D lighting system with 4 available lights
   */
  namespace Lights {
    /** Light direction attribute */
    const DIRECTION: number;
    /** Light ambient attribute */
    const AMBIENT: number;
    /** Light diffuse attribute */
    const DIFFUSE: number;

    /**
     * Configure a light source
     * @param id - Light ID (0-3)
     * @param attribute - Light attribute (Lights.DIRECTION, Lights.AMBIENT, Lights.DIFFUSE)
     * @param x - X component of attribute
     * @param y - Y component of attribute
     * @param z - Z component of attribute
     */
    function set(id: number, attribute: number, x: number, y: number, z: number): void;
  }

  /**
   * Screen module - Display management, buffer control, and rendering parameters
   */
  namespace Screen {
    /**
     * Runs a loop function every frame with automatic clear/flip
     * @param loopFn - Function to call each frame
     */
    function display(loopFn: () => void): void;

    /**
     * Persists a clear color used by Screen.display and as default for Screen.clear()
     * @param color - Packed RGBA color value (from Color.new)
     */
    function clearColor(color: number): void;

    /**
     * Clears the current draw buffer
     * @param color - Packed RGBA color value (default: transparent black)
     */
    function clear(color?: number): void;

    /**
     * Submits all queued draw packets and swaps the display buffers
     */
    function flip(): void;

    /**
     * Returns VRAM usage in bytes
     * @param statId - Statistic ID (default: VRAM_USED_TOTAL)
     * @returns VRAM usage in bytes
     */
    function getMemoryStats(statId?: number): number;

    /** Total VRAM size statistic */
    const VRAM_SIZE: number;
    /** Total VRAM used statistic */
    const VRAM_USED_TOTAL: number;
    /** Static VRAM usage statistic */
    const VRAM_USED_STATIC: number;
    /** Dynamic VRAM usage statistic */
    const VRAM_USED_DYNAMIC: number;

    /**
     * Enables/disables VSync (locks FPS to the mode's refresh rate)
     * @param enabled - Whether VSync is enabled
     */
    function setVSync(enabled: boolean): void;

    /**
     * Enables internal FPS counter required by Screen.getFPS()
     * @param enabled - Whether frame counter is enabled
     */
    function setFrameCounter(enabled: boolean): void;

    /**
     * Blocks until the next vertical blank
     */
    function waitVblankStart(): void;

    /**
     * Returns the measured FPS over the given window
     * @param frameIntervalMs - Measurement window in milliseconds (default: 1000)
     * @returns Frames per second
     */
    function getFPS(frameIntervalMs?: number): number;

    /**
     * Video mode object
     */
    interface VideoMode {
      /** Video mode identifier */
      mode: number;
      /** Screen width in pixels */
      width: number;
      /** Screen height in pixels */
      height: number;
      /** Pixel storage mode */
      psm: number;
      /** Interlaced mode flag */
      interlace: boolean;
      /** Field rendering flag */
      field: boolean;
      /** Double buffering flag */
      double_buffering: boolean;
      /** Z-buffering enabled flag */
      zbuffering: boolean;
      /** Z-buffer pixel storage mode */
      psmz: number;
      /** Number of rendering passes */
      pass_count: number;
    }

    /**
     * Returns the active video mode object
     * @returns Current video mode configuration
     */
    function getMode(): VideoMode;

    /**
     * Applies a video mode previously fetched/edited via Screen.getMode()
     * @param canvas - Video mode configuration object
     */
    function setMode(canvas: VideoMode): void;

    /**
     * Allocates internal draw/display/depth buffers (required for off-screen rendering APIs)
     */
    function initBuffers(): void;

    /**
     * Restores the buffers created by initBuffers()
     */
    function resetBuffers(): void;

    /** Draw buffer identifier */
    const DRAW_BUFFER: number;
    /** Display buffer identifier */
    const DISPLAY_BUFFER: number;
    /** Depth buffer identifier */
    const DEPTH_BUFFER: number;

    /**
     * Returns the GS surface bound to a buffer
     * @param bufferId - Buffer identifier (DRAW_BUFFER, DISPLAY_BUFFER, DEPTH_BUFFER)
     * @returns GS surface information
     */
    function getBuffer(bufferId: number): any;

    /**
     * Replaces a buffer with a renderable Image
     * @param bufferId - Buffer identifier
     * @param image - Image to use as buffer
     * @param mask - Optional mask value (default: 0)
     */
    function setBuffer(bufferId: number, image: Image, mask?: number): void;

    /**
     * Toggles between the two GS drawing contexts
     * @returns Active context ID
     */
    function switchContext(): number;

    /**
     * Forces pending GIF packets to be flushed immediately
     */
    function flush(): void;

    /**
     * Alpha blending equation configuration
     */
    interface AlphaBlendEquation {
      /** A component source */
      a: number;
      /** B component source */
      b: number;
      /** C component source */
      c: number;
      /** D component source */
      d: number;
      /** Fix argument for C when using ALPHA_FIX */
      fix: number;
    }

    /**
     * Scissor bounds configuration
     */
    interface ScissorBounds {
      /** Start X coordinate */
      x1: number;
      /** Start Y coordinate */
      y1: number;
      /** End X coordinate */
      x2: number;
      /** End Y coordinate */
      y2: number;
    }

    /**
     * Low-level access to GS render state (get)
     * @param param - Parameter identifier
     * @returns Parameter value
     */
    function getParam(param: number): any;

    /**
     * Low-level access to GS render state (set)
     * @param param - Parameter identifier
     * @param value - Parameter value (can be raw integer or helper object)
     */
    function setParam(param: number, value: any): void;

    /**
     * Utility that packs the GS alpha-blend formula into a 64-bit value
     * @param a - A component
     * @param b - B component
     * @param c - C component
     * @param d - D component
     * @param fix - Fix argument for C when using ALPHA_FIX
     * @returns Packed 64-bit value
     */
    function alphaEquation(a: number, b: number, c: number, d: number, fix: number): number;

    // Parameter constants
    /** Alpha blending equation parameter */
    const ALPHA_BLEND_EQUATION: number;
    /** Alpha test enable parameter */
    const ALPHA_TEST_ENABLE: number;
    /** Alpha test method parameter */
    const ALPHA_TEST_METHOD: number;
    /** Alpha test reference parameter */
    const ALPHA_TEST_REF: number;
    /** Alpha test fail behavior parameter */
    const ALPHA_TEST_FAIL: number;
    /** Destination alpha test enable parameter */
    const DST_ALPHA_TEST_ENABLE: number;
    /** Destination alpha test method parameter */
    const DST_ALPHA_TEST_METHOD: number;
    /** Depth test enable parameter */
    const DEPTH_TEST_ENABLE: number;
    /** Depth test method parameter */
    const DEPTH_TEST_METHOD: number;
    /** Pixel alpha blend enable parameter */
    const PIXEL_ALPHA_BLEND_ENABLE: number;
    /** Color clamp mode parameter */
    const COLOR_CLAMP_MODE: number;
    /** Scissor bounds parameter */
    const SCISSOR_BOUNDS: number;

    // Alpha blending sources
    /** Source RGB */
    const SRC_RGB: number;
    /** Framebuffer RGB */
    const DST_RGB: number;
    /** Zero RGB */
    const ZERO_RGB: number;
    /** Source alpha */
    const SRC_ALPHA: number;
    /** Framebuffer alpha */
    const DST_ALPHA: number;
    /** Alpha fix argument */
    const ALPHA_FIX: number;

    // Alpha test methods
    /** All pixels fail */
    const ALPHA_NEVER: number;
    /** All pixels pass */
    const ALPHA_ALWAYS: number;
    /** Pixel alpha < reference passes */
    const ALPHA_LESS: number;
    /** Pixel alpha <= reference passes */
    const ALPHA_LEQUAL: number;
    /** Pixel alpha == reference passes */
    const ALPHA_EQUAL: number;
    /** Pixel alpha >= reference passes */
    const ALPHA_GEQUAL: number;
    /** Pixel alpha > reference passes */
    const ALPHA_GREATER: number;
    /** Pixel alpha != reference passes */
    const ALPHA_NEQUAL: number;

    // Alpha test fail behaviors
    /** Neither frame buffer nor depth buffer are updated */
    const ALPHA_FAIL_NO_UPDATE: number;
    /** Only frame buffer is updated */
    const ALPHA_FAIL_FB_ONLY: number;
    /** Only depth buffer is updated */
    const ALPHA_FAIL_ZB_ONLY: number;
    /** Only RGB in framebuffer is updated */
    const ALPHA_FAIL_RGB_ONLY: number;

    // Destination alpha test methods
    /** Destination alpha bit == 0 passes */
    const DST_ALPHA_ZERO: number;
    /** Destination alpha bit == 1 passes */
    const DST_ALPHA_ONE: number;

    // Depth test methods
    /** All pixels fail */
    const DEPTH_NEVER: number;
    /** All pixels pass */
    const DEPTH_ALWAYS: number;
    /** Pixel Z >= depth buffer Z passes */
    const DEPTH_GEQUAL: number;
    /** Pixel Z > depth buffer Z passes */
    const DEPTH_GREATER: number;

    // Z buffer pixel storage modes (from earlier specification)
    /** Z16S pixel storage mode */
    const Z16S: number;
  }

  /**
 * Font class - Text rendering with support for bitmap and TrueType fonts
 */
  class Font {
    /**
     * Create a new font
     * @param path - Path to font file (png, bmp, jpg, otf, ttf)
     */
    constructor(path: string);

    /** Font tint color (default: white with 128 alpha) */
    color: number; // packed RGBA via Color.new

    /** Proportional scale (default: 1.0) */
    scale: number;

    /** Outline tint color (default: black with 128 alpha) */
    outline_color: number; // packed RGBA via Color.new

    /** Outline size (default: 0.0) - Note: outline and drop shadow cannot both be non-zero */
    outline: number;

    /** Drop shadow tint color (default: black with 128 alpha) */
    dropshadow_color: number; // packed RGBA via Color.new

    /** Shadow drop position (default: 0.0) - Note: outline and drop shadow cannot both be non-zero */
    dropshadow: number;

    /** Font alignment (default: Font.ALIGN_NONE) */
    align: number;

    /**
     * Draw text on screen (call every frame)
     * @param x - X coordinate for text position
     * @param y - Y coordinate for text position
     * @param text - Text to render
     */
    print(x: number, y: number, text: string): void;

    /**
     * Get text size in pixels
     * @param text - Text to measure
     * @returns Object with width and height properties
     */
    getTextSize(text: string): { width: number; height: number };
  }

  /**
   * Font alignment constants
   */
  namespace Font {
    /** No alignment (default) */
    const ALIGN_NONE: number;
    /** Align to top */
    const ALIGN_TOP: number;
    /** Align to bottom */
    const ALIGN_BOTTOM: number;
    /** Align to left */
    const ALIGN_LEFT: number;
    /** Align to right */
    const ALIGN_RIGHT: number;
    /** Align vertically centered */
    const ALIGN_VCENTER: number;
    /** Align horizontally centered */
    const ALIGN_HCENTER: number;
    /** Align both vertically and horizontally centered */
    const ALIGN_CENTER: number;
  }

  /**
   * Gamepad object returned by Pads.get()
   */
  interface Gamepad {
    /** Button state on current check */
    btns: number;
    /** Button state on last check */
    old_btns: number;
    /** Left analog horizontal position (-127 to 128) */
    lx: number;
    /** Left analog vertical position (-127 to 128) */
    ly: number;
    /** Right analog horizontal position (-127 to 128) */
    rx: number;
    /** Right analog vertical position (-127 to 128) */
    ry: number;

    /**
     * Updates all pads pressed and stick positions data
     */
    update(): void;

    /**
     * Checks if a button is being pressed (continuously)
     * @param button - Button to check
     * @returns true if button is currently pressed
     */
    pressed(button: number): boolean;

    /**
     * Checks if a button was pressed only once
     * @param button - Button to check
     * @returns true if button was just pressed this frame
     */
    justPressed(button: number): boolean;

    /**
     * Sets the pad object to listen to events defined by Pads.newEvent
     */
    setEventHandler(): void;
  }

  /**
   * Pads module - PlayStation 2 controller input system
   */
  namespace Pads {
    // Button constants
    const SELECT: number;
    const START: number;
    const UP: number;
    const RIGHT: number;
    const DOWN: number;
    const LEFT: number;
    const TRIANGLE: number;
    const CIRCLE: number;
    const CROSS: number;
    const SQUARE: number;
    const L1: number;
    const R1: number;
    const L2: number;
    const R2: number;
    const L3: number;
    const R3: number;

    // Pad type constants
    const DIGITAL: number;
    const ANALOG: number;
    const DUALSHOCK: number;

    // Event kind constants
    const PRESSED: number;
    const JUST_PRESSED: number;
    const NON_PRESSED: number;

    /**
     * Get gamepad object for specified port
     * @param port - Controller port (0-1)
     * @returns Gamepad object
     */
    function get(port: number): Gamepad;

    /**
     * Create an asynchronous pad event
     * @param button - Button to monitor
     * @param kind - Event kind (PRESSED, JUST_PRESSED, NON_PRESSED)
     * @param callback - Function to call when event occurs
     * @returns Event ID
     */
    function newEvent(button: number, kind: number, callback: () => void): number;

    /**
     * Delete an event created by Pads.newEvent
     * @param eventId - Event ID to delete
     */
    function deleteEvent(eventId: number): void;

    /**
     * Get gamepad type in specified port
     * @param port - Controller port (0-1)
     * @returns Pad type (DIGITAL, ANALOG, DUALSHOCK)
     */
    function getType(port: number): number;

    /**
     * Get button pressure level
     * @param port - Controller port (0-1)
     * @param button - Button to check
     * @returns Pressure level (0-255)
     */
    function getPressure(port: number, button: number): number;

    /**
     * Rumble gamepad motors
     * @param port - Controller port (0-1)
     * @param big - Big motor intensity (0-255)
     * @param small - Small motor intensity (0-255)
     */
    function rumble(port: number, big: number, small: number): void;
  }

  /**
   * Keyboard module - USB keyboard input
   */
  namespace Keyboard {
    /**
     * Initialize keyboard routines
     */
    function init(): void;

    /**
     * Get current keyboard character
     * @returns Character code or 0 if no key pressed
     */
    function get(): number;

    /**
     * Set keyboard repeat rate
     * @param msec - Repeat delay in milliseconds
     */
    function setRepeatRate(msec: number): void;

    /**
     * Set keyboard blocking mode
     * @param mode - Blocking mode (true to block, false for non-blocking)
     */
    function setBlockingMode(mode: boolean): void;

    /**
     * Destroy keyboard routines
     */
    function deinit(): void;
  }

  /**
   * Mouse state object
   */
  interface MouseState {
    /** X coordinate */
    x: number;
    /** Y coordinate */
    y: number;
    /** Mouse wheel delta */
    wheel: number;
    /** Button state bitmask */
    buttons: number;
  }

  /**
   * Mouse module - USB mouse input
   */
  namespace Mouse {
    /** Absolute positioning mode */
    const ABSOLUTE: number;
    /** Relative positioning mode */
    const RELATIVE: number;

    /**
     * Initialize mouse routines
     */
    function init(): void;

    /**
     * Get current mouse state
     * @returns Mouse state object
     */
    function get(): MouseState;

    /**
     * Set mouse boundary limits
     * @param minx - Minimum X coordinate
     * @param maxx - Maximum X coordinate
     * @param miny - Minimum Y coordinate
     * @param maxy - Maximum Y coordinate
     */
    function setBoundary(minx: number, maxx: number, miny: number, maxy: number): void;

    /**
     * Get current mouse mode
     * @returns Mouse mode (ABSOLUTE or RELATIVE)
     */
    function getMode(): number;

    /**
     * Set mouse mode
     * @param mode - Mouse mode (ABSOLUTE or RELATIVE)
     */
    function setMode(mode: number): void;

    /**
     * Get mouse acceleration
     * @returns Acceleration value
     */
    function getAccel(): number;

    /**
     * Set mouse acceleration
     * @param val - Acceleration value
     */
    function setAccel(val: number): void;

    /**
     * Set mouse pointer position
     * @param x - X coordinate
     * @param y - Y coordinate
     */
    function setPosition(x: number, y: number): void;
  }

  /**
   * System module - Low-level system operations and utilities
   */
  namespace System {
    // Native call argument types
    const T_LONG: number;
    const T_ULONG: number;
    const T_INT: number;
    const T_UINT: number;
    const T_SHORT: number;
    const T_USHORT: number;
    const T_CHAR: number;
    const T_UCHAR: number;
    const T_PTR: number;
    const T_BOOL: number;
    const T_FLOAT: number;
    const T_STRING: number;
    const JS_BUFFER: number;

    /**
     * Native function argument specification
     */
    interface NativeArgument {
      type: number;
      value: any;
    }

    /**
     * BDM device information
     */
    interface BDMInfo {
      name: string;
      index: number;
    }

    /**
     * Memory card information
     */
    interface MCInfo {
      type: number;
      freemem: number;
      format: number;
    }

    /**
     * CPU (Emotion Engine) information
     */
    interface CPUInfo {
      implementation: number;
      revision: number;
      FPUimplementation: number;
      FPUrevision: number;
      ICacheSize: number;
      DCacheSize: number;
      RAMSize: number;
      MachineSize: number;
    }

    /**
     * GPU (Graphics Synthesizer) information
     */
    interface GPUInfo {
      id: number;
      revision: number;
    }

    /**
     * Memory usage statistics
     */
    interface MemoryStats {
      core: number;
      nativeStack: number;
      allocs: number;
      used: number;
    }

    /**
     * Directory entry information
     */
    interface DirEntry {
      name: string;
      size: number;
      directory: boolean;
    }

    /**
     * Available device information
     */
    interface DeviceInfo {
      name: string;
      desc: string;
    }

    /**
     * File operation progress
     */
    interface FileProgress {
      current: number;
      final: number;
    }

    /**
     * Call a native function at memory address
     * @param address - Memory address of native function
     * @param arguments - Array of argument specifications
     * @param returnType - Return type (optional, void if omitted)
     * @returns Function return value
     */
    function nativeCall(address: number, arguments: NativeArgument[], returnType?: number): any;

    /**
     * Load a relocatable code module
     * @param path - Path to relocatable module
     * @returns Relocation ID
     */
    function loadReloc(path: string): number;

    /**
     * Unload a relocatable code module
     * @param relocId - Relocation ID to unload
     * Warning: Ensure no code from this module is still in use
     */
    function unloadReloc(relocId: number): void;

    /**
     * Find symbol in Athena binary or loaded relocatable modules
     * @param symbolName - Symbol name to find
     * @returns Memory address of symbol
     */
    function findRelocObject(symbolName: string): number;

    /**
     * Find symbol in specific relocatable module
     * @param relocId - Relocation ID
     * @param symbolName - Symbol name to find
     * @returns Memory address of symbol
     */
    function findRelocLocalObject(relocId: number, symbolName: string): number;

    /**
     * Get BDM (Block Device Manager) device information
     * @param device - Device name (e.g., "mass0")
     * @returns BDM device information
     */
    function getBDMInfo(device: string): BDMInfo;

    /**
     * Mount a filesystem
     * @param mountpoint - Mount point path
     * @param device - Device to mount
     * @param mode - Optional mount mode
     * @returns Mount result (0 on success)
     */
    function mount(mountpoint: string, device: string, mode?: number): number;

    /**
     * Unmount a filesystem
     * @param path - Mount point path
     * @returns Unmount result (0 on success)
     */
    function umount(path: string): number;

    /**
     * Get list of available devices
     * @returns Array of device information
     */
    function devices(): DeviceInfo[];

    /**
     * List directory contents
     * @param path - Directory path (optional, uses current directory if omitted)
     * @returns Array of directory entries
     */
    function listDir(path?: string): DirEntry[];

    /**
     * Remove directory
     * @param path - Directory path to remove
     */
    function removeDirectory(path: string): void;

    /**
     * Copy file
     * @param source - Source file path
     * @param dest - Destination file path
     */
    function copyFile(source: string, dest: string): void;

    /**
     * Move file
     * @param source - Source file path
     * @param dest - Destination file path
     */
    function moveFile(source: string, dest: string): void;

    /**
     * Rename file
     * @param source - Current file path
     * @param dest - New file path
     */
    function rename(source: string, dest: string): void;

    /**
     * Sleep for specified seconds
     * @param sec - Seconds to sleep
     */
    function sleep(sec: number): void;

    /**
     * Exit to PlayStation 2 browser
     */
    function exitToBrowser(): void;

    /**
     * Set dark mode preference
     * @param value - Dark mode enabled
     */
    function setDarkMode(value: boolean): void;

    /**
     * Get system temperature (SCPH-500XX and later models only)
     * @returns Temperature in degrees Celsius or null if not supported
     */
    function getTemperature(): number | null;

    /**
     * Get memory card information
     * @param slot - Memory card slot (0-1)
     * @returns Memory card information
     */
    function getMCInfo(slot: number): MCInfo;

    /**
     * Get CPU (Emotion Engine) information
     * @returns CPU information
     */
    function getCPUInfo(): CPUInfo;

    /**
     * Get GPU (Graphics Synthesizer) information
     * @returns GPU information
     */
    function getGPUInfo(): GPUInfo;

    /**
     * Get memory usage statistics
     * @returns Memory statistics
     */
    function getMemoryStats(): MemoryStats;

    /**
     * Asynchronous file copy
     * @param source - Source file path
     * @param dest - Destination file path
     */
    function threadCopyFile(source: string, dest: string): void;

    /**
     * Get file operation progress
     * @returns File progress information
     */
    function getFileProgress(): FileProgress;
  }

  /**
 * Mutex class - Mutual exclusion for thread synchronization
 */
  class Mutex {
    constructor();

    /**
     * Acquire the lock (blocks if already locked)
     */
    lock(): void;

    /**
     * Release the lock
     */
    unlock(): void;
  }

  /**
   * Thread information interface
   */
  interface ThreadInfo {
    id: number;
    name: string;
    status: number;
    stack_size: number;
  }

  /**
   * Thread module - Thread management and creation
   */
  namespace Thread {
    /**
     * List all system threads (OS level, not JavaScript itself)
     * @returns Array of thread information objects
     */
    function list(): ThreadInfo[];

    /**
     * Force kill a thread from an internal ID
     * @param id - Thread ID to kill
     */
    function kill(id: number): void;
  }

  /**
   * Thread class - JavaScript thread execution
   */
  class Thread {
    /**
     * Create a new thread
     * @param callback - Function to execute in the thread
     * @param name - Optional thread name (max 64 characters, useful for tracking)
     */
    constructor(callback: () => void, name?: string);

    /**
     * Set the thread to an active state
     */
    start(): void;

    /**
     * Finish thread execution, changing it to the state before calling start()
     */
    stop(): void;

    /** Thread internal ID (read-only) */
    readonly id: number;

    /** Thread name (read-only) */
    readonly name: string;
  }

  /**
   * Timer class - High-resolution timer for timing operations
   */
  namespace Timer {
    /**
     * Create a new timer
     * @returns Timer handle
     */
    function new (): number;

    /**
     * Get current timer value
     * @param timer - Timer handle
     * @returns Timer value in milliseconds
     */
    function getTime(timer: number): number;

    /**
     * Set timer value
     * @param timer - Timer handle
     * @param value - New timer value in milliseconds
     */
    function setTime(timer: number, value: number): void;

    /**
     * Destroy timer and free resources
     * @param timer - Timer handle to destroy
     */
    function destroy(timer: number): void;

    /**
     * Pause timer (stop counting)
     * @param timer - Timer handle to pause
     */
    function pause(timer: number): void;

    /**
     * Resume timer (continue counting)
     * @param timer - Timer handle to resume
     */
    function resume(timer: number): void;

    /**
     * Reset timer to zero
     * @param timer - Timer handle to reset
     */
    function reset(timer: number): void;

    /**
     * Check if timer is currently running
     * @param timer - Timer handle to check
     * @returns true if timer is running
     */
    function isPlaying(timer: number): boolean;
  }

  /**
   * Audio stream class for background music
   */
  class SoundStream {
    /**
     * Play or resume audio stream
     */
    play(): void;

    /**
     * Free audio stream from memory
     */
    free(): void;

    /**
     * Pause audio stream
     */
    pause(): void;

    /**
     * Check if the audio stream is being played
     * @returns true if audio is playing
     */
    playing(): boolean;

    /**
     * Restart audio to its beginning
     * Note: Should call play() again if it's not the current track
     */
    rewind(): void;

    /** Current track playtime in milliseconds (get/set) */
    position: number;

    /** Current track duration in milliseconds (read-only) */
    readonly length: number;

    /** Loop playback (get/set) */
    loop: boolean;
  }

  /**
   * Sound effect class for short audio clips
   */
  class SoundSfx {
    /**
     * Play sound effect
     * @param channel - Optional channel index (uses free channel if not specified)
     * @returns Channel index if channel was auto-selected, undefined otherwise
     */
    play(channel?: number): number | undefined;

    /**
     * Free sound effect from memory
     */
    free(): void;

    /**
     * Check if the sound effect is being played on specified channel
     * @param channel - Channel index to check
     * @returns true if sound is playing on channel
     */
    playing(channel: number): boolean;

    /** Current sound effect volume (0-100, get/set) */
    volume: number;

    /** Sound effect spatial panning (-100 left to 100 right, 0 center, get/set) */
    pan: number;

    /** Sound effect pitch (-100 to 100, 0 default, get/set) */
    pitch: number;
  }

  /**
   * Sound module - Audio playback and management
   */
  namespace Sound {
    /**
     * Set master volume
     * @param volume - Master volume (0-100)
     */
    function setVolume(volume: number): void;

    /**
     * Find first free channel for sound effect playback
     * @returns Channel index or -1 if no free channels
     */
    function findChannel(): number;

    /**
     * Load audio stream file (WAV, OGG)
     * @param path - Path to audio file
     * @returns SoundStream object
     */
    function Stream(path: string): SoundStream;

    /**
     * Load sound effect (ADPCM)
     * @param path - Path to sound file
     * @returns SoundSfx object
     */
    function Sfx(path: string): SoundSfx;
  }

  /**
   * Projector class for real-time shadow projection
   */
  class ShadowsProjector {
    /**
     * Create a new shadow projector
     * @param shadowTexture - Texture for shadow appearance
     */
    constructor(shadowTexture: Image);

    /**
     * Set shadow projection area size in world units
     * @param width - Width in world units
     * @param height - Height in world units
     */
    setSize(width: number, height: number): void;

    /**
     * Set grid resolution for shadow tessellation (minimum 2x2)
     * @param gridX - X resolution
     * @param gridZ - Z resolution
     */
    setGrid(gridX: number, gridZ: number): void;

    /**
     * Set directional light direction (automatically normalized)
     * @param x - X component
     * @param y - Y component
     * @param z - Z component
     */
    setLightDir(x: number, y: number, z: number): void;

    /**
     * Set shadow bias to prevent z-fighting
     * @param bias - Bias value (default: 0.01)
     */
    setBias(bias: number): void;

    /**
     * Set offset along light direction to shift shadow center
     * @param offset - Offset value
     */
    setLightOffset(offset: number): void;

    /**
     * Set maximum slope angle for shadow projection (optional)
     * @param maxSlopeCos - Maximum slope cosine value
     */
    setSlopeLimit(maxSlopeCos: number): void;

    /**
     * Set shadow color and alpha
     * @param r - Red component (0.0-1.0)
     * @param g - Green component (0.0-1.0)
     * @param b - Blue component (0.0-1.0)
     * @param a - Alpha component (0.0-1.0)
     */
    setColor(r: number, g: number, b: number, a: number): void;

    /**
     * Set shadow blend mode
     * @param mode - Blend mode constant
     */
    setBlend(mode: number): void;

    /**
     * Set texture UV rectangle for shadow appearance
     * @param u0 - U coordinate start (0.0-1.0)
     * @param v0 - V coordinate start (0.0-1.0)
     * @param u1 - U coordinate end (0.0-1.0)
     * @param v1 - V coordinate end (0.0-1.0)
     */
    setUVRect(u0: number, v0: number, u1: number, v1: number): void;

    /**
     * Enable/disable ODE ray casting for accurate shadow placement
     * @param space - ODE space handle (if available)
     * @param rayLength - Maximum ray length
     * @param enable - Whether to enable ray casting
     */
    enableRaycast(space: any, rayLength: number, enable: boolean): void;

    /**
     * Render the shadow projector (call every frame)
     */
    render(): void;

    /** Projector world position {x, y, z} */
    position: { x: number; y: number; z: number };

    /** Projector rotation {x, y, z} (quaternion) */
    rotation: { x: number; y: number; z: number };

    /** Projector scale {x, y, z} */
    scale: { x: number; y: number; z: number };
  }

  /**
   * Shadows module - Real-time shadow projection system
   */
  namespace Shadows {
    /** Darken blend mode (default) */
    const SHADOW_BLEND_DARKEN: number;

    /** Alpha blend mode */
    const SHADOW_BLEND_ALPHA: number;

    /** Additive blend mode */
    const SHADOW_BLEND_ADD: number;

    /**
     * Shadow projector constructor alias
     */
    const Projector: typeof ShadowsProjector;
  }

  /**
     * Archive module - ZIP and TAR archive manipulation
     */
  namespace Archive {
    /**
     * Archive handle type (opaque)
     */
    type ArchiveHandle = number;

    /**
     * Archive entry information
     */
    interface ArchiveEntry {
      name: string;
      size: number;
      compressed_size: number;
      is_directory: boolean;
    }

    /**
     * Open an archive file
     * @param fname - Path to archive file
     * @returns Archive handle
     */
    function open(fname: string): ArchiveHandle;

    /**
     * List contents of archive
     * @param zip - Archive handle
     * @returns Array of archive entries
     */
    function list(zip: ArchiveHandle): ArchiveEntry[];

    /**
     * Extract all files from archive
     * @param zip - Archive handle
     */
    function extractAll(zip: ArchiveHandle): void;

    /**
     * Close archive and free resources
     * @param zip - Archive handle
     */
    function close(zip: ArchiveHandle): void;

    /**
     * Extract TAR archive
     * @param fname - Path to TAR file
     */
    function untar(fname: string): void;
  }

  /**
   * IOP module - IOP (I/O Processor) module management
   */
  namespace IOP {
    /**
     * IOP module handle type (opaque)
     */
    type IOPModuleHandle = number;

    /**
     * IOP memory statistics
     */
    interface IOPMemoryStats {
      free: number;
      used: number;
    }

    /**
     * Create a new IOP module
     * @param name - Module name
     * @param data - Module data (string for file path, ArrayBuffer for memory)
     * @param arg_len - Optional argument length
     * @param args - Optional arguments
     * @returns IOP module handle
     */
    function newModule(name: string, data: string | ArrayBuffer, arg_len?: number, args?: ArrayBuffer): IOPModuleHandle;

    /**
     * Load an IOP module
     * @param module - IOP module handle
     * @param arg - Optional argument
     */
    function loadModule(module: IOPModuleHandle, arg?: ArrayBuffer): void;

    /**
     * Reset IOP system
     */
    function reset(): void;

    /**
     * Get IOP memory statistics
     * @returns Memory statistics
     */
    function getMemoryStats(): IOPMemoryStats;
  }

  /**
   * Network module - Network interface configuration
   */
  namespace Network {
    /**
     * Network configuration
     */
    interface NetworkConfig {
      ip: string;
      netmask: string;
      gateway: string;
      dns: string;
    }

    /**
     * Initialize network module
     * @param ip - Static IP address (omit for DHCP)
     * @param netmask - Network mask (required if ip is provided)
     * @param gateway - Default gateway (required if ip is provided)
     * @param dns - DNS server (required if ip is provided)
     */
    function init(ip?: string, netmask?: string, gateway?: string, dns?: string): void;

    /**
     * Get current network configuration
     * @returns Network configuration
     */
    function getConfig(): NetworkConfig;

    /**
     * Shutdown network module
     */
    function deinit(): void;
  }

  /**
   * HTTP request class
   */
  class Request {
    constructor();

    /** Keep connection alive for multiple requests */
    keepalive: boolean;

    /** User agent string */
    useragent: string;

    /** User credentials (username:password) */
    userpwd: string;

    /** Custom HTTP headers */
    headers: string[];

    /**
     * Perform HTTP GET request
     * @param url - Request URL
     * @returns Response data
     */
    get(url: string): any;

    /**
     * Perform HTTP HEAD request
     * @param url - Request URL
     * @returns Response headers
     */
    head(url: string): any;

    /**
     * Perform HTTP POST request
     * @param url - Request URL
     * @param data - POST data
     * @returns Response data
     */
    post(url: string, data: string | ArrayBuffer): any;

    /**
     * Download file
     * @param url - File URL
     * @param fname - Local filename to save to
     * @returns Download result
     */
    download(url: string, fname: string): any;

    /**
     * Perform asynchronous HTTP GET request
     * @param url - Request URL
     */
    asyncGet(url: string): void;

    /**
     * Asynchronously download file
     * @param url - File URL
     * @param fname - Local filename to save to
     */
    asyncDownload(url: string, fname: string): void;

    /**
     * Check if asynchronous operation is ready
     * @param timeout - Operation timeout in milliseconds
     * @param conn_timeout - Connection timeout in milliseconds
     * @returns true if operation is complete
     */
    ready(timeout?: number, conn_timeout?: number): boolean;

    /**
     * Get asynchronous response data
     * @returns Response data
     */
    getAsyncData(): any;

    /**
     * Get asynchronous response size
     * @returns Response size in bytes
     */
    getAsyncSize(): number;
  }

  /**
   * Socket module - TCP/UDP network sockets
   */
  namespace Socket {
    /** Internet address family */
    const AF_INET: number;
    /** Stream socket type (TCP) */
    const SOCK_STREAM: number;
    /** Datagram socket type (UDP) */
    const SOCK_DGRAM: number;
    /** Raw socket type */
    const SOCK_RAW: number;

    /**
     * Network socket class
     */
    class Socket {
      /**
       * Create new socket
       * @param domain - Address family (AF_INET)
       * @param type - Socket type (SOCK_STREAM, SOCK_DGRAM, SOCK_RAW)
       */
      constructor(domain: number, type: number);

      /**
       * Connect to remote host
       * @param host - Hostname or IP address
       * @param port - Port number
       * @returns Connection result
       */
      connect(host: string, port: number): boolean;

      /**
       * Bind socket to local address
       * @param host - Local hostname or IP address
       * @param port - Local port number
       * @returns Bind result
       */
      bind(host: string, port: number): boolean;

      /**
       * Start listening for connections
       * @returns Listen result
       */
      listen(): boolean;

      /**
       * Send data
       * @param data - Data to send (ArrayBuffer or string)
       * @returns Number of bytes sent
       */
      send(data: ArrayBuffer | string): number;

      /**
       * Receive data
       * @param size - Maximum bytes to receive
       * @returns Received data as ArrayBuffer
       */
      recv(size: number): ArrayBuffer;

      /**
       * Close socket
       */
      close(): void;
    }
  }

  /**
   * WebSocket module - WebSocket client
   */
  class WebSocket {
    /**
     * Create new WebSocket connection
     * @param url - WebSocket URL (ws:// or wss://)
     */
    constructor(url: string);

    /**
     * Send data
     * @param data - Data to send (ArrayBuffer or string)
     * @returns Number of bytes sent
     */
    send(data: ArrayBuffer | string): number;

    /**
     * Receive data
     * @returns Received data as ArrayBuffer
     */
    recv(): ArrayBuffer;
  }

  /**
   * ODE module - Open Dynamics Engine physics simulation
   */
  namespace ODE {
    /**
     * Vector3 type for 3D positions/vectors
     */
    type Vector3 = [number, number, number];

    /**
     * Rotation matrix type (3x3 matrix as array of 9 numbers)
     */
    type RotationMatrix = [
      number, number, number,
      number, number, number,
      number, number, number
    ];

    /**
     * Ray parameters
     */
    interface RayParams {
      firstContact: boolean;
      backfaceCull: boolean;
    }

    /**
         * Body class - Rigid body in physics simulation
         */
    class Body {
      /**
       * Set body position
       * @param x - X coordinate
       * @param y - Y coordinate
       * @param z - Z coordinate
       */
      setPosition(x: number, y: number, z: number): void;

      /**
       * Get body position
       * @returns Position vector [x, y, z]
       */
      getPosition(): Vector3;

      /**
       * Set body rotation
       * @param matrix - 3x3 rotation matrix or quaternion
       */
      setRotation(matrix: RotationMatrix | number[]): void;

      /**
       * Get body rotation
       * @returns Current rotation matrix
       */
      getRotation(): RotationMatrix;

      /**
       * Set linear velocity
       * @param x - X velocity component
       * @param y - Y velocity component
       * @param z - Z velocity component
       */
      setLinearVel(x: number, y: number, z: number): void;

      /**
       * Get linear velocity
       * @returns Velocity vector [vx, vy, vz]
       */
      getLinearVel(): Vector3;

      /**
       * Set angular velocity
       * @param x - X angular velocity component
       * @param y - Y angular velocity component
       * @param z - Z angular velocity component
       */
      setAngularVel(x: number, y: number, z: number): void;

      /**
       * Get angular velocity
       * @returns Angular velocity vector [wx, wy, wz]
       */
      getAngularVel(): Vector3;

      /**
       * Set body mass
       * @param mass - Mass value
       */
      setMass(mass: number): void;

      /**
       * Set mass from a box shape
       * @param density - Material density
       * @param lx - Box length in X direction
       * @param ly - Box length in Y direction
       * @param lz - Box length in Z direction
       */
      setMassBox(density: number, lx: number, ly: number, lz: number): void;

      /**
       * Set mass from a sphere shape
       * @param density - Material density
       * @param radius - Sphere radius
       */
      setMassSphere(density: number, radius: number): void;

      /**
       * Apply a linear force
       * @param x - X component of force
       * @param y - Y component of force
       * @param z - Z component of force
       */
      addForce(x: number, y: number, z: number): void;

      /**
       * Apply a torque
       * @param x - X component of torque
       * @param y - Y component of torque
       * @param z - Z component of torque
       */
      addTorque(x: number, y: number, z: number): void;

      /**
       * Enable simulation for the body
       */
      enable(): void;

      /**
       * Disable simulation for the body
       */
      disable(): void;

      /**
       * Check if body is enabled
       * @returns true if enabled, false otherwise
       */
      enabled(): boolean;

      /**
       * Free the body resources
       */
      free(): void;
    }


    /**
         * World class - Physical simulation world
         */
    class World {
      /**
       * Set the world gravity vector
       * @param x - X component of gravity
       * @param y - Y component of gravity
       * @param z - Z component of gravity
       */
      setGravity(x: number, y: number, z: number): void;

      /**
       * Get the world gravity vector
       * @returns Gravity vector [x, y, z]
       */
      getGravity(): Vector3;

      /**
       * Set the Constraint Force Mixing parameter
       * @param value - CFM value
       */
      setCFM(value: number): void;

      /**
       * Set the Error Reduction Parameter
       * @param value - ERP value
       */
      setERP(value: number): void;

      /**
       * Advance the simulation by dt seconds
       * @param dt - Time step in seconds
       */
      step(dt: number): void;

      /**
       * Advance the simulation using the quick step integrator
       * @param dt - Time step in seconds
       */
      quickStep(dt: number): void;

      /**
       * Set the number of iterations for the quick step solver
       * @param iter - Number of iterations
       */
      setQuickStepIterations(iter: number): void;

      /**
       * Advance the simulation including collision detection
       * @param dt - Time step in seconds
       * @param space - Space for collision detection
       * @param jointGroup - Joint group for contact joints
       */
      stepWithContacts(dt: number, space: Space, jointGroup: JointGroup): void;

      /**
       * Free all resources associated with the world
       */
      destroyWorld(): void;
    }

    /**
     * Ray state
     */
    interface RayState {
      start: Vector3;
      direction: Vector3;
    }

    /**
     * Contact information from ray collision
     */
    interface RayContact {
      position: Vector3;
      normal: Vector3;
      depth: number;
    }

    /**
     * JointGroup class - Group of temporary joints
     */
    class JointGroup {
      /**
       * Remove all joints from the group
       */
      empty(): void;

      /**
       * Free the group resources
       */
      free(): void;
    }

    /**
     * Base Joint class - Physical constraint between bodies
     */
    class Joint {
      /**
       * Free joint resources
       */
      free(): void;

      /**
       * Attach joint to two bodies
       * @param body1 - First body
       * @param body2 - Second body
       */
      attach(body1: Body, body2: Body): void;
    }

    /**
     * Ball Joint - Spherical joint
     */
    class BallJoint extends Joint {
      /**
       * Set anchor point
       * @param x - X coordinate
       * @param y - Y coordinate
       * @param z - Z coordinate
       */
      setBallAnchor(x: number, y: number, z: number): void;

      /**
       * Get anchor point
       * @returns Anchor vector [x, y, z]
       */
      getBallAnchor(): Vector3;
    }

    /**
     * Hinge Joint - Rotational joint around a single axis
     */
    class HingeJoint extends Joint {
      /**
       * Set anchor point
       * @param x - X coordinate
       * @param y - Y coordinate
       * @param z - Z coordinate
       */
      setHingeAnchor(x: number, y: number, z: number): void;

      /**
       * Set axis direction
       * @param x - X component
       * @param y - Y component
       * @param z - Z component
       */
      setHingeAxis(x: number, y: number, z: number): void;

      /**
       * Apply torque to hinge
       * @param t - Torque magnitude
       */
      addHingeTorque(t: number): void;

      /**
       * Get anchor point
       * @returns Anchor vector [x, y, z]
       */
      getHingeAnchor(): Vector3;

      /**
       * Get axis direction
       * @returns Axis vector [x, y, z]
       */
      getHingeAxis(): Vector3;

      /**
       * Get hinge angle
       * @returns Angle in radians
       */
      getHingeAngle(): number;

      /**
       * Get hinge angular velocity
       * @returns Angular velocity in radians/second
       */
      getHingeAngleRate(): number;
    }

    /**
     * Slider Joint - Translational joint along a single axis
     */
    class SliderJoint extends Joint {
      /**
       * Set axis direction
       * @param x - X component
       * @param y - Y component
       * @param z - Z component
       */
      setSliderAxis(x: number, y: number, z: number): void;

      /**
       * Apply force to slider
       * @param f - Force magnitude
       */
      addSliderForce(f: number): void;

      /**
       * Get axis direction
       * @returns Axis vector [x, y, z]
       */
      getSliderAxis(): Vector3;

      /**
       * Get slider position
       * @returns Position along axis
       */
      getSliderPosition(): number;

      /**
       * Get slider velocity
       * @returns Velocity along axis
       */
      getSliderPositionRate(): number;
    }

    /**
     * Hinge2 Joint - Two rotational joints (like a car suspension)
     */
    class Hinge2Joint extends Joint {
      /**
       * Set anchor point
       * @param x - X coordinate
       * @param y - Y coordinate
       * @param z - Z coordinate
       */
      setHinge2Anchor(x: number, y: number, z: number): void;

      /**
       * Set first axis direction
       * @param x - X component
       * @param y - Y component
       * @param z - Z component
       */
      setHinge2Axis1(x: number, y: number, z: number): void;

      /**
       * Set second axis direction
       * @param x - X component
       * @param y - Y component
       * @param z - Z component
       */
      setHinge2Axis2(x: number, y: number, z: number): void;

      /**
       * Apply torques to both axes
       * @param t1 - Torque on axis 1
       * @param t2 - Torque on axis 2
       */
      addHinge2Torques(t1: number, t2: number): void;

      /**
       * Get anchor point
       * @returns Anchor vector [x, y, z]
       */
      getHinge2Anchor(): Vector3;

      /**
       * Get first axis direction
       * @returns Axis vector [x, y, z]
       */
      getHinge2Axis1(): Vector3;

      /**
       * Get second axis direction
       * @returns Axis vector [x, y, z]
       */
      getHinge2Axis2(): Vector3;

      /**
       * Get angle of first axis
       * @returns Angle in radians
       */
      getHinge2Angle1(): number;

      /**
       * Get angular velocity of first axis
       * @returns Angular velocity in radians/second
       */
      getHinge2Angle1Rate(): number;

      /**
       * Get angular velocity of second axis
       * @returns Angular velocity in radians/second
       */
      getHinge2Angle2Rate(): number;
    }

    /**
     * Universal Joint - Two rotational joints with perpendicular axes
     */
    class UniversalJoint extends Joint {
      /**
       * Set anchor point
       * @param x - X coordinate
       * @param y - Y coordinate
       * @param z - Z coordinate
       */
      setUniversalAnchor(x: number, y: number, z: number): void;

      /**
       * Set first axis direction
       * @param x - X component
       * @param y - Y component
       * @param z - Z component
       */
      setUniversalAxis1(x: number, y: number, z: number): void;

      /**
       * Set second axis direction
       * @param x - X component
       * @param y - Y component
       * @param z - Z component
       */
      setUniversalAxis2(x: number, y: number, z: number): void;

      /**
       * Apply torques to both axes
       * @param t1 - Torque on axis 1
       * @param t2 - Torque on axis 2
       */
      setUniversalTorques(t1: number, t2: number): void;

      /**
       * Get anchor point
       * @returns Anchor vector [x, y, z]
       */
      getUniversalAnchor(): Vector3;

      /**
       * Get first axis direction
       * @returns Axis vector [x, y, z]
       */
      getUniversalAxis1(): Vector3;

      /**
       * Get second axis direction
       * @returns Axis vector [x, y, z]
       */
      getUniversalAxis2(): Vector3;

      /**
       * Get angle of first axis
       * @returns Angle in radians
       */
      getUniversalAngle1(): number;

      /**
       * Get angle of second axis
       * @returns Angle in radians
       */
      getUniversalAngle2(): number;

      /**
       * Get angular velocity of first axis
       * @returns Angular velocity in radians/second
       */
      getUniversalAngle1Rate1(): number;

      /**
       * Get angular velocity of second axis
       * @returns Angular velocity in radians/second
       */
      getUniversalAngle2Rate2(): number;
    }

    /**
     * Fixed Joint - Rigidly connects two bodies
     */
    class FixedJoint extends Joint {
      /**
       * Fix the current relative position and orientation
       */
      setFixed(): void;
    }

    /**
     * AMotor Joint - Angular motor for controlling relative orientation
     */
    class AMotorJoint extends Joint {
      /**
       * Set number of axes
       * @param n - Number of axes (1-3)
       */
      setAMotorNumAxes(n: number): void;

      /**
       * Set motor axis
       * @param index - Axis index (0-2)
       * @param rel - Relative mode (0: global, 1: body1, 2: body2)
       * @param x - X component
       * @param y - Y component
       * @param z - Z component
       */
      setAMotorAxis(index: number, rel: number, x: number, y: number, z: number): void;

      /**
       * Set angle for given axis
       * @param axis - Axis index (0-2)
       * @param angle - Angle in radians
       */
      setAMotorAngle(axis: number, angle: number): void;

      /**
       * Set motor mode
       * @param mode - Motor mode (0: user, 1: Euler, 2: 2-axis)
       */
      setAMotorMode(mode: number): void;

      /**
       * Apply torques to motor axes
       * @param x - X axis torque
       * @param y - Y axis torque
       * @param z - Z axis torque
       */
      setAMotorTorques(x: number, y: number, z: number): void;

      /**
       * Get number of axes
       * @returns Number of axes
       */
      getAMotorNumAxes(): number;

      /**
       * Get axis direction
       * @param index - Axis index (0-2)
       * @returns Axis vector [x, y, z]
       */
      getAMotorAxis(index: number): Vector3;

      /**
       * Get axis relative mode
       * @param index - Axis index (0-2)
       * @returns Relative mode (0: global, 1: body1, 2: body2)
       */
      getAMotorAxisRel(index: number): number;

      /**
       * Get axis angle
       * @param index - Axis index (0-2)
       * @returns Angle in radians
       */
      getAMotorAngle(index: number): number;

      /**
       * Get axis angular velocity
       * @param index - Axis index (0-2)
       * @returns Angular velocity in radians/second
       */
      getAMotorAngleRate(index: number): number;

      /**
       * Get motor mode
       * @returns Motor mode
       */
      getAMotorMode(): number;
    }

    /**
     * Ray geometry specialized methods
     */
    interface RayGeometry {
      /**
       * Set ray length
       * @param length - New ray length
       */
      raySetLength(length: number): void;

      /**
       * Get ray length
       * @returns Current ray length
       */
      rayGetLength(): number;

      /**
       * Set ray position and direction
       * @param px - Start X position
       * @param py - Start Y position
       * @param pz - Start Z position
       * @param dx - Direction X component
       * @param dy - Direction Y component
       * @param dz - Direction Z component
       */
      raySet(px: number, py: number, pz: number, dx: number, dy: number, dz: number): void;

      /**
       * Get ray state
       * @returns Object with start position and direction
       */
      rayGet(): RayState;

      /**
       * Configure ray behavior
       * @param firstContact - If true, returns only the first contact found
       * @param backfaceCull - If true, ignores back-facing surfaces
       */
      raySetParams(firstContact: boolean, backfaceCull: boolean): void;

      /**
       * Get current ray parameters
       * @returns Ray parameters
       */
      rayGetParams(): RayParams;

      /**
       * Set closest hit mode
       * @param closestHit - If true, returns only the closest hit
       */
      raySetClosestHit(closestHit: boolean): void;

      /**
       * Get closest hit mode
       * @returns Whether closest hit mode is enabled
       */
      rayGetClosestHit(): boolean;
    }

    /**
         * Geom class - Collision geometry
         */
    class Geom {
      /**
       * Set geometry position
       * @param x - X coordinate
       * @param y - Y coordinate
       * @param z - Z coordinate
       */
      setPosition(x: number, y: number, z: number): void;

      /**
       * Set geometry rotation
       * @param matrix - 3x3 rotation matrix
       */
      setRotation(matrix: RotationMatrix): void;

      /**
       * Get geometry position
       * @returns Position vector [x, y, z]
       */
      getPosition(): Vector3;

      /**
       * Get geometry rotation
       * @returns Rotation matrix
       */
      getRotation(): RotationMatrix;

      /**
       * Attach this geometry to a body
       * @param body - Body to attach to
       */
      setBody(body: Body): void;

      /**
       * Get the attached body
       * @returns Attached body or null
       */
      getBody(): Body | null;

      /**
       * Free geometry resources
       */
      free(): void;
    }

    /**
         * Space class - Collision detection space
         */
    class Space {
      /**
       * Run collision detection between all geometries in the space
       * @param callback - Function called for each colliding pair: (geom1: Geom, geom2: Geom) => void
       */
      collide(callback: (geom1: Geom, geom2: Geom) => void): void;

      /**
       * Free space resources
       */
      free(): void;
    }


    // Global functions
    /**
     * Finalize ODE and release global resources
     */
    function cleanup(): void;

    /**
     * Check for collision between two geometries
     * @param geom1 - First geometry
     * @param geom2 - Second geometry
     * @returns Contact information if collision detected, null otherwise
     */
    function geomCollide(geom1: Geom, geom2: Geom): RayContact | null;

    // Geometry creation functions (alternative naming)
    /**
     * Create geometry from render object
     * @param renderObj - RenderObject to create geometry from
     * @param space - Space to add geometry to
     * @returns Created geometry
     */
    function GeomRenderObject(renderObj: any, space: Space): Geom;

    /**
     * Create box geometry
     * @param space - Space to add geometry to
     * @param lx - Length in X direction
     * @param ly - Length in Y direction
     * @param lz - Length in Z direction
     * @returns Box geometry
     */
    function GeomBox(space: Space, lx: number, ly: number, lz: number): Geom & RayGeometry;

    /**
     * Create sphere geometry
     * @param space - Space to add geometry to
     * @param radius - Sphere radius
     * @returns Sphere geometry
     */
    function GeomSphere(space: Space, radius: number): Geom & RayGeometry;

    /**
     * Create plane geometry
     * @param space - Space to add geometry to
     * @param a - Plane normal X component
     * @param b - Plane normal Y component
     * @param c - Plane normal Z component
     * @param d - Plane constant
     * @returns Plane geometry
     */
    function GeomPlane(space: Space, a: number, b: number, c: number, d: number): Geom & RayGeometry;

    /**
     * Create transform geometry
     * @param space - Space to add geometry to
     * @param geom - Base geometry to transform
     * @returns Transform geometry
     */
    function GeomTransform(space: Space, geom: Geom): Geom & RayGeometry;

    /**
     * Create ray geometry for raycasting
     * @param space - Space to add geometry to
     * @param length - Ray length
     * @returns Ray geometry with specialized methods
     */
    function GeomRay(space: Space, length: number): Geom & RayGeometry;

    // Joint creation functions (alternative naming)
    /**
     * Create ball joint
     * @param world - Physics world
     * @param group - Joint group (optional)
     * @returns Ball joint
     */
    function JointBall(world: World, group?: JointGroup): BallJoint;

    /**
     * Create hinge joint
     * @param world - Physics world
     * @param group - Joint group (optional)
     * @returns Hinge joint
     */
    function JointHinge(world: World, group?: JointGroup): HingeJoint;

    /**
     * Create slider joint
     * @param world - Physics world
     * @param group - Joint group (optional)
     * @returns Slider joint
     */
    function JointSlider(world: World, group?: JointGroup): SliderJoint;

    /**
     * Create hinge2 joint
     * @param world - Physics world
     * @param group - Joint group (optional)
     * @returns Hinge2 joint
     */
    function JointHinge2(world: World, group?: JointGroup): Hinge2Joint;

    /**
     * Create universal joint
     * @param world - Physics world
     * @param group - Joint group (optional)
     * @returns Universal joint
     */
    function JointUniversal(world: World, group?: JointGroup): UniversalJoint;

    /**
     * Create fixed joint
     * @param world - Physics world
     * @param group - Joint group (optional)
     * @returns Fixed joint
     */
    function JointFixed(world: World, group?: JointGroup): FixedJoint;

    /**
     * Create null joint
     * @param world - Physics world
     * @param group - Joint group (optional)
     * @returns Null joint
     */
    function JointNull(world: World, group?: JointGroup): Joint;

    /**
     * Create AMotor joint
     * @param world - Physics world
     * @param group - Joint group (optional)
     * @returns AMotor joint
     */
    function JointAMotor(world: World, group?: JointGroup): AMotorJoint;

    // Structure creation functions (alternative naming)
    /**
     * Create new world
     * @returns Physics world
     */
    function World(): World;

    /**
     * Create new space
     * @returns Space for collision detection
     */
    function Space(): Space;

    /**
     * Create new body
     * @param world - Physics world
     * @returns Rigid body
     */
    function Body(world: World): Body;

    /**
     * Create new joint group
     * @returns Joint group
     */
    function JointGroup(): JointGroup;
  }
}

export { };