/** @type {import('typescript/lib/tsserverlibrary').PluginModuleFactory} */
function init(ts) {
  const path = require('path');
  
  const FLOAT_F_RE =
    /(?<![\w$])(?:\d[\d_]*(?:\.\d[\d_]*)?|\.\d[\d_]*)(?:[eE][+\-]?\d[\d_]*)?f(?![\w$])/g;

  function transformText(text) {
    return text.replace(FLOAT_F_RE, m => m.slice(0, -1) + " ");
  }

  function fileIsJSLike(file) {
    return file.endsWith(".js") || file.endsWith(".jsx");
  }

  function create(info) {
    try {
      info.project.projectService.logger.info("[athenaenv-extension-plugin] loaded");
    } catch {}

    const host = info.languageServiceHost;
    const typesPath = path.resolve(__dirname, 'types', 'athenaenv.d.ts');
    
    try {
      info.project.projectService.logger.info(
        `[athenaenv-extension-plugin] Types path: ${typesPath}`
      );
      
      const originalGetScriptFileNames = host.getScriptFileNames?.bind(host);
      if (originalGetScriptFileNames) {
        host.getScriptFileNames = () => {
          const files = originalGetScriptFileNames();
          if (!files.includes(typesPath)) {
            files.push(typesPath);
            info.project.projectService.logger.info(
              `[athenaenv-extension-plugin] Types injected successfully`
            );
          }
          return files;
        };
      }
    } catch (e) {
      try {
        info.project.projectService.logger.info(
          `[athenaenv-extension-plugin] Error injecting types: ${e}`
        );
      } catch {}
    }

    try {
      const originalGetCompilationSettings = host.getCompilationSettings?.bind(host);
      if (originalGetCompilationSettings) {
        host.getCompilationSettings = () => {
          const settings = originalGetCompilationSettings();
          
          settings.lib = [
            'lib.es2015.d.ts',
            'lib.es2016.d.ts',
            'lib.es2017.d.ts',
            'lib.es2018.d.ts',
            'lib.es2019.d.ts',
            'lib.es2020.d.ts'
          ];
          settings.noLib = false;
          
          info.project.projectService.logger.info(
            `[athenaenv-extension-plugin] Compilation settings updated (DOM disabled)`
          );
          
          return settings;
        };
      }
    } catch (e) {
      try {
        info.project.projectService.logger.info(
          `[athenaenv-extension-plugin] Error updating compilation settings: ${e}`
        );
      } catch {}
    }
    const originalGetScriptSnapshot = host.getScriptSnapshot?.bind(host);

    if (originalGetScriptSnapshot) {
      host.getScriptSnapshot = fileName => {
        const snap = originalGetScriptSnapshot(fileName);
        if (!snap || !fileIsJSLike(fileName)) return snap;

        const fullLen = snap.getLength();
        const origText = snap.getText(0, fullLen);
        if (!FLOAT_F_RE.test(origText)) {
          FLOAT_F_RE.lastIndex = 0;
          return snap;
        }
        FLOAT_F_RE.lastIndex = 0;

        const transformed = transformText(origText);
        const safeSnapshotFactory =
          ts && ts.ScriptSnapshot && ts.ScriptSnapshot.fromString
            ? ts.ScriptSnapshot.fromString
            : (s => ({ getText: (a, b) => s.slice(a, b), getLength: () => s.length, getChangeRange: () => undefined }));

        return safeSnapshotFactory(transformed);
      };
    }

    const ls = info.languageService;

    function createFFloatRanges(text) {
      FLOAT_F_RE.lastIndex = 0;
      const ranges = [];
      let m;
      while ((m = FLOAT_F_RE.exec(text))) {
        ranges.push({ start: m.index, end: m.index + m[0].length });
      }
      return ranges;
    }

    function overlaps(start, length, bStart, bEnd) {
      const aStart = start ?? 0;
      const aEnd = aStart + (length ?? 0);
      return !(aEnd <= bStart || aStart >= bEnd);
    }

    function filterDiagnosticsForFile(fileName, diags) {
      try {
        if (!fileIsJSLike(fileName)) return diags;
        const sf = ls.getProgram()?.getSourceFile(fileName);
        if (!sf) return diags;

        const text = sf.getFullText();
        const ranges = createFFloatRanges(text);
        if (!ranges.length) return diags;

        return diags.filter(d => {
          const s = d.start ?? 0;
          const l = d.length ?? 0;
          for (const r of ranges) {
            if (overlaps(s, l, r.start, r.end)) return false;
          }
          return true;
        });
      } catch {
        return diags;
      }
    }

    const proxy = Object.create(null);
    for (const k of Object.keys(ls)) proxy[k] = (...a) => ls[k](...a);

    proxy.getSyntacticDiagnostics = f =>
      filterDiagnosticsForFile(f, ls.getSyntacticDiagnostics(f));
    proxy.getSemanticDiagnostics = f =>
      filterDiagnosticsForFile(f, ls.getSemanticDiagnostics(f));
    proxy.getSuggestionDiagnostics = f =>
      filterDiagnosticsForFile(f, ls.getSuggestionDiagnostics?.(f) ?? []);

    return proxy;
  }

  return { create };
}

module.exports = init;